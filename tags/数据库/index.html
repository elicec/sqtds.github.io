<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>蜻蜓点水</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="蜻蜓点水">
<meta property="og:url" content="http://sqtds.github.io/tags/数据库/index.html">
<meta property="og:site_name" content="蜻蜓点水">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蜻蜓点水">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="蜻蜓点水" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1bd1f966e3148e2b59e4b159067ad372";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="/img/photo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">sqtds</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/sqtds" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="/sqtds@163.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 15.71px;">android</a><a href="/tags/antlr4/" style="font-size: 18.57px;">antlr4</a><a href="/tags/hadoop/" style="font-size: 11.43px;">hadoop</a><a href="/tags/impala/" style="font-size: 10px;">impala</a><a href="/tags/java/" style="font-size: 11.43px;">java</a><a href="/tags/java核心系列/" style="font-size: 20px;">java核心系列</a><a href="/tags/java源码阅读/" style="font-size: 12.86px;">java源码阅读</a><a href="/tags/linux/" style="font-size: 14.29px;">linux</a><a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a><a href="/tags/mondrian/" style="font-size: 18.57px;">mondrian</a><a href="/tags/netty/" style="font-size: 10px;">netty</a><a href="/tags/nosql/" style="font-size: 11.43px;">nosql</a><a href="/tags/spring/" style="font-size: 14.29px;">spring</a><a href="/tags/tomcat/" style="font-size: 17.14px;">tomcat</a><a href="/tags/分布式/" style="font-size: 10px;">分布式</a><a href="/tags/异常/" style="font-size: 10px;">异常</a><a href="/tags/性能/" style="font-size: 10px;">性能</a><a href="/tags/数据库/" style="font-size: 15.71px;">数据库</a><a href="/tags/缓存/" style="font-size: 10px;">缓存</a><a href="/tags/计算机原理/" style="font-size: 15.71px;">计算机原理</a><a href="/tags/随笔/" style="font-size: 11.43px;">随笔</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">sqtds</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">sqtds</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/sqtds" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="/sqtds@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2015/column-base-store" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/22/2015/column-base-store/" class="article-date">
  	<time datetime="2015-08-22T06:51:05.000Z" itemprop="datePublished">8月 22 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/22/2015/column-base-store/">列式压缩技术汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一，前言">一，前言</h2><p>孔子说，温故而知新，可以为师矣。好久没探讨列式数据库了，今天在此再次总结一遍，供以后查阅。本文介绍的内容如下：<br><img src="/img/2015/列式存储.png" alt=""></p>
<h2 id="二，存储算法">二，存储算法</h2><p>对于一列值，你认为会有哪些存储方式呢？下面我们来看看常用的存储算法：</p>
<h3 id="2-1_dictionary(字典项编码)">2.1 dictionary(字典项编码)</h3><p>这个最常用的，不说了，so easy。</p>
<h3 id="2-2_bit_Vector（比特向量）">2.2 bit Vector（比特向量）</h3><p>适用于重复度比较高的。<br>比如一列 ABAABCCCAABB<br>对于字段值A,B,C分别用一个bit Vector来存储他们的位置。<br>A 101100001100<br>B 010010000011<br>C 000001110000</p>
<h3 id="2-3_RLE（Run-length_encoding，行程编码）">2.3 RLE（Run-length encoding，行程编码）</h3><p>RLE适合用于对已排序好的数据进行编码。<br>RLE由一下3部分组成：</p>
<blockquote>
<p>控制符+重复次数+被重复字符</p>
</blockquote>
<p>例如，字符串 RTAAAASDEEEEE<br>经RLE压缩后为： RT<em>4ASD</em>5E</p>
<p>在这里，”<em>4A” 代替了流”AAAA”，”</em>5E” 代替”EEEEE”。其中，控制符采用特殊字符’*’ 指出一个RLE编码的开始，后面的数字表示重复的次数，数字后的单个字符是被重复的字符。显然，重复字符数为4或大于4，RLE编码效率才高，因为一个重复至少需要3个符号来表示。</p>
<h3 id="2-4_LZ算法簇">2.4 LZ算法簇</h3><p>LZ算法簇包括LZ77，LZW，LZ78，LZSS，他们都是以LZ77算法为基础的，我们重点介绍LZ77算法。</p>
<p>我们先看个例子： the brown fox jumped over the brown foxy jumping frog<br>这个短语的长度总共是53个八位组 = 424 bit。算法从左向右处理这个文本。初始时，每个字符被映射成9 bit的编码，二进制的1跟着该字符的8 bit ASCII码。在处理进行时，算法查找重复的序列。当碰到一个重复时，算法继续扫描直到该重复序列终止。换句话说，每次出现一个重复时，算法包括尽可能多的字符。碰到的第一个这样的序列是the brown fox。这个序列被替换成指向前一个序列的指针和序列的长度。在这种情况下，前一个序列的the brown fox出现在26个字符之前，序列的长度是13个字符。对于这个例子，假定存在两种编码选项：8 bit的指针和4 bit的长度，或者12 bit的指针和6 bit的长度。使用2 bit的首部来指示选择了哪种选项，00表示第一种选项，01表示第二种选项。因此，the brown fox的第二次出现被编码为 <00b><26d><13 d="">，或者00 00011010 1101。<br>压缩报文的剩余部分是字母y；序列<00b><27d><5 d="">替换了由一个空格跟着jump组成的序列，以及字符序列ing frog。<br>下图演示了压缩映射的过程。压缩过的报文由35个9 bit字符和两个编码组成，总长度为35 x 9 + 2 x 14 = 343比特。和原来未压缩的长度为424比特的报文相比，压缩比为1.24。<br><img src="/img/2015/lz77-example短语.gif" alt=""></5></27d></00b></13></26d></00b></p>
<p>LZ77（及其变体）的压缩算法使用了两个缓存。<strong>滑动历史缓存</strong>包含了前面处理过的N个源字符，<strong>前向缓存</strong>包含了将要处理的下面L个字符。算法尝试将前向缓存开始的两个或多个字符与滑动历史缓存中的字符串相匹配。如果没有发现匹配，前向缓存的第一个字符作为9 bit的字符输出并且移入滑动窗口，滑动窗口中最久的字符被移出。如果找到匹配，算法继续扫描以找出最长的匹配。然后匹配字符串作为三元组输出（指示标记、指针和长度）。对于K个字符的字符串，滑动窗口中最久的K个字符被移出，并且被编码的K个字符被移入窗口。</p>
<p><img src="/img/2015/lz77-算法.gif" alt=""></p>
<p><img src="/img/2015/lz77-例子.gif" alt=""></p>
<h3 id="2-5_哈弗曼编码">2.5 哈弗曼编码</h3><p>哈弗曼编码为前缀编码，即一个编码不是另一个编码的前缀。<br><img src="/img/2015/哈弗曼.jpg" alt=""></p>
<h3 id="2-6_trie">2.6 trie</h3><p>Trie数据结构一般也叫prefix trees, 一般用在数据类型为string并且排序之后有明显倾斜的数据分布的列，比如URL , 家庭住址, 这些字段的前缀经过排序之后在局部区域往往都有很高的压缩比，在最近的Hbase 里面也使用了这种方式压缩rowKey 的部分，Google PowerDrill也同时使用Trie Encoding压缩由”字典表”和”字典表所在位置”所组成的文件格式及其对应的内存数据结构.</p>
<h2 id="三，数据库">三，数据库</h2><p>对于列式数据库都有哪些，他们都有哪些优缺点，下面我们将介绍一下。</p>
<h3 id="3-1_impala">3.1 impala</h3><p>impala是基于hadoop大数据的列式数据库。impala主要使用的列式存储是parquet。</p>
<p>impala的性能快的原因：</p>
<ul>
<li>Impala不需要把中间结果写入磁盘，省掉了大量的I/O开销。</li>
<li>省掉了MapReduce作业启动的开销。</li>
<li>Impala完全抛弃了MapReduce这个不太适合做SQL查询的范式，而是像Dremel一样借鉴了MPP并行数据库的思想另起炉灶，因此可做更多的查询优化，从而省掉不必要的shuffle、sort等开销。</li>
<li>用C++实现，做了很多有针对性的硬件优化，例如使用SSE指令。</li>
<li>使用了支持Data locality的I/O调度机制，尽可能地将数据和计算分配在同一台机器上进行，减少了网络开销。</li>
</ul>
<h3 id="3-2_hbase">3.2 hbase</h3><p>hbase建立的hdfs之上，提供高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。</p>
<h3 id="3-3_infobright">3.3 infobright</h3><p>infobright是基于mysql的,它也是利用了MPP分布式架构。<br>infobright相比其他的数据库最大的特点就是知识网格的特性。<br>Knowledge Grid（知识网格）包含了Data Pack Node（知识节点），每个知识节点又对应于一个Data Pack（数据块）。<br>存储层最底层就是一个个的Data Pack（数据块）。每一个Pack装着某一列的64K个元素，所有数据按照这样的形式打包存储，每一个数据块进行类型相关的压缩（即根据不同数据类型采 用不同的压缩算法），压缩比很高。<br><img src="/img/2015/infobright-arti.png" alt=""></p>
<h3 id="3-4_greenplum">3.4 greenplum</h3><p>Greenplum是一种基于postgresql的分布式数据库,它也利用了MPP分布式架构。</p>
<h3 id="3-5_dremel">3.5 dremel</h3><p>Dremel 是Google 的“交互式”数据分析系统。可以组建成规模上千的集群，处理PB级别的数据。<br>Dremel的特点：</p>
<ul>
<li>按列存储的嵌套数据格式</li>
<li>多级执行查询树</li>
</ul>
<h3 id="3-6_monetdb">3.6 monetdb</h3><p>monetdb暂时介绍的太少，没有商用。</p>
<h2 id="四，其他">四，其他</h2><p>说了这么多，那么列式数据库的高效到底在哪里？为什么列存储会比行存储更高效呢？我们看看其原理：</p>
<h3 id="4-1_原理">4.1 原理</h3><p>列式查询的原理就是延迟物化，直到最后才把值查出来。<br>假设我们用的数据字典压缩存储列。如果要查询符合条件的记录，我们可以按照以下方式：</p>
<ol>
<li>去字典表里找到字符串对应数字。</li>
<li>用数字去列表里匹配，匹配上的位置设为1。</li>
<li>把不同列的匹配结果进行位运算得到符合所有条件的记录下标。</li>
<li>使用这个下标组装出最终的结果集。<br><img src="/img/2015/column-query.png" alt=""></li>
</ol>
<h3 id="4-2_特点">4.2 特点</h3><p>列式数据库优点：</p>
<ul>
<li>极高的装载速度（最高可以等于所有硬盘IO的总和，基本是极限了）</li>
<li>适合大量的数据而不是小数据</li>
<li>实时加载数据仅限于增加（删除和更新需要解压缩Block 然后计算然后重新压缩储存）</li>
<li>高效的压缩率，不仅节省储存空间也节省计算内存和CPU。</li>
<li>非常适合做聚合操作。</li>
</ul>
<p>列式数据库缺点：</p>
<ul>
<li>不适合扫描小量数据</li>
<li>不适合随机的更新</li>
<li>批量更新情况各异，有的优化的比较好的列式数据库（比如Vertica）表现比较好，有些没有针对更新的数据库表现比较差。</li>
<li>不适合做含有删除和更新的实时操作。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015/sql 连续性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/17/2015/sql 连续性/" class="article-date">
  	<time datetime="2015-06-17T12:42:41.000Z" itemprop="datePublished">6月 17 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/17/2015/sql 连续性/">SQL问题 找出连续日期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天在公司遇到一个有趣的sql问题，觉得挺有趣的，那就分享下。</p>
<h2 id="问题">问题</h2><p>有如下数据，找出其中日期(rq字段)连续性大于等于3的日期。<br><img src="/img/2015/sql连续1.png" alt="图片1"></p>
<p>即，结果为如下图所示：<br><img src="/img/2015/sql连续2.png" alt="图片2"></p>
<h2 id="思考">思考</h2><p>最开始的时候，我想这至少得写存储过程吧，先排序这个表，然后再从前向后取，当遇到连续性大于2的就保留下来，以此类推，直到读取完毕。</p>
<p>后来，百度了下，发现了一个更好的方法—-<a href="http://tech.it168.com/a2012/1229/1441/000001441981_all.shtml" target="_blank" rel="external">“关于数字的经典SQL编程：连续范围问题”</a>。</p>
<h2 id="思路">思路</h2><p>在那篇文章中，题主用的是整形，我们可以类推下，整形和时间其实差不多。</p>
<h3 id="第一步，查找每行的与rownum的差值">第一步，查找每行的与rownum的差值</h3><p>在这里我们用系统时间来确定相差的天数，保证了每个时间都有唯一的对标，然后减去rownum。</p>
<pre><code><span class="operator"><span class="keyword">select</span> rq, <span class="keyword">floor</span>(rq - <span class="keyword">sysdate</span>) - rownum  <span class="keyword">as</span> diff ,rownum <span class="keyword">from</span> tmptable</span>
</code></pre><p>执行结果如下图所示，我们发现，只要时间是连续的，那么他们的差值(diff字段)一定相等。<br><img src="/img/2015/sql连续3.png" alt="图片3"></p>
<h3 id="第二步，根据分组查找大于等于3的差值">第二步，根据分组查找大于等于3的差值</h3><p>这个简单，使用havaing搞定，贴sql就行了，不多说了。</p>
<pre><code><span class="operator"><span class="keyword">select</span> diff
  <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">floor</span>(rq - <span class="keyword">sysdate</span>) - rownum <span class="keyword">as</span> diff <span class="keyword">from</span> tmptable t) aa
<span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span>
 <span class="keyword">group</span> <span class="keyword">by</span> diff</span>
</code></pre><p><img src="/img/2015/sql连续4.png" alt="图片3"></p>
<h3 id="第三步，根据差值查找出所有的行">第三步，根据差值查找出所有的行</h3><p>差值都有了，这就好办啦，我们直接使用第一步的sql和第二步的sql进行关联查询，结果就出来啦。</p>
<pre><code><span class="operator"><span class="keyword">select</span> t.rq
  <span class="keyword">from</span> 
  <span class="comment">-- 查找每行的与rownum的差值</span>
        (<span class="keyword">select</span> rq, <span class="keyword">floor</span>(rq - <span class="keyword">sysdate</span>) - rownum <span class="keyword">as</span> diff <span class="keyword">from</span> tmptable) t,
  <span class="comment">-- 根据分组查找大于等于3的差值</span>
       (<span class="keyword">select</span> diff
          <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">floor</span>(rq - <span class="keyword">sysdate</span>) - rownum <span class="keyword">as</span> diff <span class="keyword">from</span> tmptable t) aa
        <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span>
         <span class="keyword">group</span> <span class="keyword">by</span> diff) cg
 <span class="keyword">where</span> t.diff = cg.diff
 <span class="keyword">order</span> <span class="keyword">by</span> t.rq ;</span>
</code></pre><p>好了，结果就是最开始要求的数据。</p>
<h2 id="总结">总结</h2><p>在连续性这个问题上，只要我们找到了与连续性相关的字段（rownum），然后在这个字段上进行处理，就可以得到我们想要的结果了。</p>
<p>从这里我们可以看到，如果需要做某件事的时候，先找是否有与它相关联的东西，如果有，那么我们可以先从相关联的的东西上入手，然后再用死方法一步一步来。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/mysql-index" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/25/2014/mysql-index/" class="article-date">
  	<time datetime="2015-04-25T08:26:28.000Z" itemprop="datePublished">4月 25 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/25/2014/mysql-index/">mysql索引总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>索引是什么？索引是存储引擎用于快速找到记录的一种数据结构。</p>
<h2 id="索引分类">索引分类</h2><h3 id="B-Tree索引">B-Tree索引</h3><p>MyISAM使用前缀压缩技术使得索引更小。InnoDB按照原数据存储索引。<br>MyISAM索引通过数据的物理位置引用被索引的行。InnoDB根据主键引用被索引的行。<br>可以使用B-Tree索引的查询类型：</p>
<ul>
<li>全值匹配：和索引中的所有列进行匹配</li>
<li>匹配最左前缀：匹配第一个索引</li>
<li>匹配列前缀：匹配某一列的值的开头部分，只使用第一个索引</li>
<li>匹配范围值：匹配某个范围，只使用第一个索引</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
<li>排序操作：索引的有序性</li>
</ul>
<h3 id="哈希索引">哈希索引</h3><p>哈希索引基于哈希表实现，只有精确匹配所有列的查询才有效。对于每一行数据，存储引擎会对所有的索引列计算一个hash值。<br>哈希索引的限制：</p>
<ul>
<li>哈希索引只能包含哈希值和行指针，不能使用索引的值避免行读取。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li>
<li>哈希索引只支持等值查找。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突。</li>
</ul>
<h3 id="空间数据索引">空间数据索引</h3><p>地理数据索引。（略）</p>
<h3 id="全文索引">全文索引</h3><p>全文索引查找文本中的关键词，一般采用倒排索引。</p>
<h3 id="其他">其他</h3><h2 id="索引的优点">索引的优点</h2><p>索引可以让服务器快速的定位到指定的位置。</p>
<ul>
<li>索引大大减少了服务器需要扫描的数量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机IO变为顺序IO。</li>
</ul>
<p>参考:Relational Database Index Design and the Optimizers.</p>
<p>索引是最好的解决方案吗？<br>对于非常小的表，大部分情况下简单的全表扫描更高效。<br>对于中大型的表，索引就非常有效。<br>对于特大型的表，建立和使用索引的代价随之增长。可以采用分区技术等。</p>
<h2 id="索引策略">索引策略</h2><h3 id="独立的列">独立的列</h3><p>索引列不能是表达式的一部分，也不能使函数的参数。</p>
<h3 id="前缀索引和索引选择性">前缀索引和索引选择性</h3><p>有时候需要索引很长的字符列，会让索引变得很大，这是我们可以使用哈希索引。我们是否还有更好的方法？</p>
<p>通常可以索引开始的部分字符，这样可以节省索引空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<h3 id="多列索引">多列索引</h3><p>很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p>在多个列上建立独立的单列索引大部分情况下并不能提高MySql的查询性能。MySql5.0以上引入了一种“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>
<h3 id="选择合适的索引列顺序">选择合适的索引列顺序</h3><p>经验法则：将选择性最高的列放在索引最前列。</p>
<h3 id="聚簇索引">聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引索引实际上在同一个结构中保存了B-Tree索引和物理行。<br>当表有聚簇索引时，实际上它的数据行保存在索引的叶子节点中。所以，一个表中只能有一个聚簇索引。</p>
<p>聚簇索引的优点：</p>
<ul>
<li>把相关数据保存在一起</li>
<li>数据访问更快，提高了IO的性能</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入速度依赖于插入顺序。</li>
<li>更新索引的代价很高。</li>
<li>插入新行，更新主键或者移动行的时候，面临“页分裂”的问题。</li>
<li>可能导致全表扫描变慢，尤其是行稀疏，也分裂导致数据不连续</li>
<li>二级索引（非聚簇索引）可能比想象的大，因为包含了主键列。</li>
</ul>
<h3 id="覆盖索引">覆盖索引</h3><p>如果索引的叶子节点已经包含了需要查询的字段，那么还有什么必要再回表查询？如果一个索引包含所有需要查询的字段的值，我们就称为“覆盖索引”。</p>
<p>适应场景：</p>
<ul>
<li>索引条目通常远小于数据行的大小。</li>
<li>对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要小的多。</li>
<li>可内存缓存索引，避免系统调用</li>
</ul>
<h3 id="使用索引进行排序">使用索引进行排序</h3><p>当索引的列序列和order by子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySql才能够使用索引来对结果进行排序。如果查询关联多个表时，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引进行排序。ORDER BY 子句和查找型查询的限制是一样的：需要全部满足索引的最左前缀的要求；否则，MySql都需要执行排序操纵，而无法利用索引进行排序。</p>
<p>有一种情况下ORDER BY子句可以不满足索引的最左前缀要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>
<h3 id="索引和锁">索引和锁</h3><p>索引可以让查询锁定更少的行。如果你的查询不需要访问那些不需要的行，那么就会锁定更少的行。</p>
<h2 id="设计原则">设计原则</h2><h3 id="选择性特别低，并且经常用到的的作为索引前列">选择性特别低，并且经常用到的的作为索引前列</h3><p>例如性别只有2种选择，但是我们经常会用到。如果没有用到性别查询，我们也可以使用 sex in（‘m’，‘f’）来让mysql选择该索引。</p>
<p>有一点需要注意的是，使用in的方式覆盖不在where条件中查询的列，不能过度使用。因为每增加一个in条件，优化器都需要以指数的形式增加，a<em>b</em>c。</p>
<h3 id="对于经常性范围查询，应放到索引后列">对于经常性范围查询，应放到索引后列</h3><p>对于范围查询，MySql无法再使用范围列后面的其他索引了，但是对于多个“等值条件查询”则没有这个限制。<br>例如年龄查询，可能是查询某个范围的，我们就要放到后面。</p>
<h3 id="避免多个范围查询">避免多个范围查询</h3><p>使用in来代替多范围查询</p>
<h3 id="优化排序">优化排序</h3><p>对于选择性非常低的列，可以添加一些特殊的索引进行排序。<br>例如sex进行排序时，可以使用(sex,rating)索引进行排序。<br>select <cols> from table where sex=’M’ order by rating ;</cols></p>
<p>PS:本文总结来自《mysql高性能》一书</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/oracle-group-by" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/31/2014/oracle-group-by/" class="article-date">
  	<time datetime="2015-03-31T09:45:27.000Z" itemprop="datePublished">3月 31 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/31/2014/oracle-group-by/">Oracle rollup、cube、grouping sets</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Oracle的group by除了基本用法以外，还有3种扩展用法，分别是rollup、cube、grouping sets。</p>
<h2 id="1_rollup">1 rollup</h2><p>假设有一个表test，有A、B、C、D、E5列。<br>如果使用group by rollup(A,B,C)，首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。roll up的意思是“卷起”，这也可以帮助我们理解group by rollup就是对选择的列从右到左以一次少一列的方式进行grouping直到所有列都去掉后的grouping(也就是全表grouping)，对于n个参数的rollup，有n+1次的grouping。以下2个sql的结果集是一样的：</p>
<p><code>Select A,B,C,sum(E) from test group by rollup(A,B,C)</code><br>与</p>
<p><code>Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,null,null,sum(E) from test</code></p>
<h2 id="2_cube">2 cube</h2><p>cube的意思是立方，对cube的每个参数，都可以理解为取值为参与grouping和不参与grouping两个值的一个维度，然后所有维度取值组合的集合就是grouping的集合，对于n个参数的cube，有2^n次的grouping。如果使用group by cube(A,B,C),，则首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作，一共是2^3=8次grouping。同rollup一样，也可以用基本的group by加上结果集的union all写出一个与group by cube结果集相同的sql：<br><code>Select A,B,C,sum(E) from test group by cube(A,B,C);</code><br>与<br><code>Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,C,sum(E) from test group by A,C
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,B,C,sum(E) from test group by B,C
union all
Select null,B,null,sum(E) from test group by B
union all
Select null,null,C,sum(E) from test group by C
union all
Select null,null,null,sum(E) from test;</code></p>
<h2 id="3_grouping_sets">3 grouping sets</h2><p>grouping sets就是对参数中的每个参数做grouping，也就是有几个参数做几次grouping,例如使用<code>group by grouping sets(A,B,C)</code>，则对(A),(B),(C)进行group by，如果使用<code>group by grouping sets((A,B),C)</code>,则对(A,B),(C)进行group by。甚至<code>grouping by grouping set(A,A)</code>都是语法允许的，也就是对(A)进行2次group by,grouping sets的参数允许重复</p>
<h2 id="4_总结">4 总结</h2><ul>
<li>rollup        (N+1个分组方案)</li>
<li>cube         (2^N个分组方案)</li>
<li>grouping sets (自定义罗列出分组方案)</li>
</ul>
<hr>
<h2 id="5_注意点">5 注意点</h2><h3 id="5-1_机制不同">5.1 机制不同</h3><p>在rollup和cube的说明中分别给出了用基本group by加结果集union all给出了结果集相同的sql，但这只是为了理解的方便而给出的sql，并不说明rollup和cube与基本group by加结果集union all等价。实际上两者的内部机制是安全不一样的，前者除了写法简洁以外，运行时不需多次扫描表，效率远比后者高。</p>
<h3 id="5-2_集合可运算">5.2 集合可运算</h3><p>3种扩展用法的参数可以是源表中的某一个具体的列，也可以是若干列经过计算而形成的一个新列（比如说A+B，A||B），也可以是这两种列的一个集合（例如（A+B，C）），对于grouping set更是特殊，可以是空集合()，表示对全表进行group by。</p>
<h3 id="5-3_group_by_与_rollup,_cube组合使用">5.3 group by 与 rollup, cube组合使用</h3><p>Group by的基本用法以及这3种扩展用法可以组合使用，也就是说可以出现group by A,rollup(A,B)这样的用法，oracle将对出现在group by中的每种用法的grouping列集合做笛卡尔积然后对其中的每一个元素做group by。这话说起来挺绕口，举例说明吧，group by A, rollup(A,B)，基本用法的grouping集合是(A),rollup(A,B)的grouping集合是((A,B),(A),()),两个集合的笛卡尔积集合是((A,A,B),(A,A),(A))，所以会首先对(A,A,B)做group by，然后对(A,A)做group by，最后对(A)做group by。实际上对(A,A,B)做group by和对(A,B)做group by两者是完全等价的(group by A,A,B结果和group by A,B完全一样)，同理对(A,A)做group by和对(A)做group by也是等价的。简化后的结果就是首先对(A,B)做group by，然后对(A)做group by，最后再对(A)做group by。下面给出两个等价的sql以便理解：<br><code>Select A,B,sum(E) from test1 group by A, rollup(A,B);</code><br>与<br><code>Select A,B,sum(E) from test1 group by A,B
Union all
Select A,null,sum(E) from test1 group by A
Union all
Select A,null,sum(E) from test1 group by A;</code></p>
<h2 id="6_grouping()、grouping_id()、group_id()">6 grouping()、grouping_id()、group_id()</h2><h3 id="6-1_grouping()">6.1 grouping()</h3><p>参数只有一个，而且必须为group by中出现的某一列，表示结果集的一行是否对该列做了grouping。对于对该列做了grouping的行而言，grouping()=0，反之为1；</p>
<h3 id="6-2_grouping_id()">6.2 grouping_id()</h3><p>参数可以是多个，但必须为group by中出现的列。Grouping_id()的返回值其实就是参数中的每列的grouping()值的二进制向量，例如如果grouping(A)=1，grouping(B)=0，则grouping_id(A,B)的返回值就是二进制的10，转成10进制就是2。</p>
<h3 id="6-3_group_id()">6.3 group_id()</h3><p>无参数。见上面的说明3），group by对某些列的集合会进行重复的grouping，而实际上绝大多数情况下对结果集中的这些重复行是不需要的，那就必须有办法剔出这些重复grouping的行。当结果集中有n条重复grouping而形成的行时，每行的group_id()分别是0,1,…,n，这样我们在条件中加入一个group_id()&lt;1就可以剔出这些重复grouping的行了。</p>
<h2 id="7_示例">7 示例</h2><h3 id="7-1_建表与数据">7.1 建表与数据</h3><p>SQL&gt; <code>create table test(department_id number, a varchar2(20), b varchar2(20));</code></p>
<p>Table created</p>
<p>SQL&gt; <code>insert into test values(10, &#39;A&#39;, &#39;B&#39;);</code></p>
<p>1 row inserted</p>
<p>SQL&gt; <code>commit;</code></p>
<p>Commit complete</p>
<h3 id="7-2_查询语句">7.2 查询语句</h3><p><code>select department_id,
       a,
       b,
       grouping(department_id),
       grouping(a),
       grouping(b)
  from test
 group by rollup(department_id, a, b)
order by 4, 5, 6;
select department_id,
       a,
       b,
       grouping(department_id),
       grouping(a),
       grouping(b)
  from test
 group by cube(department_id, a, b)
order by 4, 5, 6;</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/列式存储机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/11/2014/列式存储机制/" class="article-date">
  	<time datetime="2014-05-11T12:17:33.000Z" itemprop="datePublished">5月 11 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/11/2014/列式存储机制/">列式存储机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="引言">引言</h3><hr>
<p>由于大数据的发展，越来越多的企业利用大数据来挖掘数据更多的价值，关系型数据库受到了越来越严重的挑战。人们迫切需要找到一个新的突破口来处理大数据。在这样的环境下，列式存储孕育而出。
      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2014/05/11/2014/列式存储机制/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 sqtds
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>