<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>蜻蜓点水</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="蜻蜓点水">
<meta property="og:url" content="http://sqtds.github.io/public/_posts/index.html">
<meta property="og:site_name" content="蜻蜓点水">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蜻蜓点水">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="蜻蜓点水" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蜻蜓点水</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">if you never try , you will lost forever.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://sqtds.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mondrian-source-code-9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/04/mondrian-source-code-9/" class="article-date">
  <time datetime="2015-04-04T10:41:49.000Z" itemprop="datePublished">4月 4 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/04/mondrian-source-code-9/">mondrian 源码解读（九）-聚集层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>包mondrian.rolap.agg，管理聚合缓存，这些缓存中包含着各单元格值。<br>RolapStar中含有aggregation(聚合)，一个aggregation是针对一组columns的，该聚合可以包含多个segment，同一个aggregation中的每个segment都将覆盖到相同的列集合；每个segment表达了一组cell值，这些cell自然是由具体的列值和一个必备度量值(如下面的unit sales)来限定，如：<code>(Unit sales, Gender = &#39;F&#39;, State  in {&#39;CA&#39;,&#39;OR&#39;}, Marital Status = anything)</code>，由于其中的列值可能会取多个，因此最终表达的cell值也可能是多个。RolapStar中有一个aggregations，是一个map对象，通过request的constrainedColumnsBitKey来索引一个aggregation。</p>
<h2 id="聚合装载过程">聚合装载过程</h2><p>实际中无论是底层的单元值还是聚合后的单元值都是放在聚合对象aggregation中的。以aggregation.load(colums,measures,predicates,pinnedSegments)为入口：</p>
<p>参数中的除了measure不一样外，其限定的列(colums)及列值（prediactes）都是一致的。因此转换成对对若干segment[]的求值： Segment.load(segment[]，….)，在该方法内部：</p>
<ul>
<li>首先根据segments中的信息生成sql查询语句，有两个不同的生成类：AggQuerySpec和SegmentArrayQuerySpec，前者用于找到聚合表情况下的sql语句生成，后者用于基于原始表的sql语句生成。具体可以参见它们的generateSqlQuery()方法，这里注意对以distinct count有不同的生成方法。Sql生成的核心类是sqlQuery，类似于交换系统中的QuerySqlFactory类。注意：聚合操作如avg、sum等都最终还是利用sql语句实现的，并非mondiran自己实现这些聚合功能。</li>
<li>利用jdbc，执行sql语句，获取到jdbc 结果集。参见mondrian.rolap.RolapUtil.executeQuery()方法。</li>
<li>解析结果集，将结果集中的数据填充到rows[][]二维数值中，并且把各列的值也填充好。如图：<br>结果集每条记录的值如宁波市、G010….,前面两个是维度列值，后面几个是度量值。<br><img src="/img/mondrain_agg1.png" alt=""><br>各列的值(其中第0项值为：[宁波市])：<br><img src="/img/mondrain_agg2.png" alt=""></li>
<li>决定采用稀疏性(sparse)还是稠密性（dense）SegmentDataSet存储；并创建该空的DataSet对象。每个segment关联一个DataSet对象；但其稀疏性还是稠密性都是一致的。注意dataset中单元值的个数可能是1个或多个，是由各限定列的指定值个数乘积，若所有限定列都取单值，则显然最终决定一个唯一的单元。</li>
<li>将上述的rows中间集转换到SegmentDataSets集中。最后再分拣给每个segment，确保每个segment的setData(SegmentDataSet)被调用。</li>
</ul>
<h2 id="segment详解">segment详解</h2><p>下图是有两个限定列的两个segment的描述(注:其中roadid列虽然指定了8个候选值，但由于使用了空行/列过滤，最后只剩下两个路线有值，故最后segment结果集的单元数也只有两个，对应于G010和G318的)：<br><img src="/img/mondrain_agg3.png" alt=""><br><img src="/img/mondrain_agg4.png" alt=""><br>其中第二个对应的dataset为：<br>[317.769, 120.604]<br>对应的透视界面为(参见其中的“观测里程”度量值，与上面的dataset一致)：<br><img src="/img/mondrain_agg5.png" alt=""></p>
<p>再譬如有三个限定列的segment描述，它们位于另一个aggreation对象中：(其中timeId列的any代表所以可能的时间值，共有2003~2005三个年，所以最终该segment共有3个cell值)<br><img src="/img/mondrain_agg6.png" alt=""><br>对应的dataset为：<br>[129.910, 129.909, 57.950]<br>对应的透视界面为(显然该aggreation还有另外一个segment，其中的roadId对应于G010—宁波梁辉)：<br><img src="/img/mondrain_agg7.png" alt=""></p>
<p>再譬如维度中有多个层次的情况时，一个维度会对应多个列：</p>
<pre><code><span class="type">Query</span> query = connection.parseQuery(
    <span class="string">"SELECT"</span> +
    <span class="string">" {[Time].[1997],"</span> +
    <span class="string">" [Time].[1997].Children} ON COLUMNS,"</span> +
    <span class="string">" {[Customer].[USA],"</span> +
    <span class="string">" [Customer].[USA].[OR],"</span> +
    <span class="string">" [Customer].[USA].[WA]} ON ROWS"</span> +
    <span class="string">"FROM [Sales]"</span>);
<span class="type">Result</span> <span class="literal">result</span> = connection.execute(query);
</code></pre><p>该语句执行后产生的segment分别为(除了第一个外，其他segment都会包含多个cell，因为它们的限定列中含有多值的情况)：</p>
<pre><code>Segment YN<span class="comment">#1    Year Nation Unit Sales</span>
                <span class="number">1997</span> USA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Nation=</span>USA

Segment YNS<span class="comment">#1    Year Nation State Unit Sales</span>
                <span class="number">1997</span> USA    OR    xxx
                <span class="number">1997</span> USA    WA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Nation=</span>USA, <span class="variable">State=</span>{OR, WA}

Segment YQN<span class="comment">#1    Year Quarter Nation Unit Sales</span>
                <span class="number">1997</span> Q1      USA    xxx
                <span class="number">1997</span> Q2      USA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Quarter=</span>any, <span class="variable">Nation=</span>USA

Segment YQNS<span class="comment">#1    Year Quarter Nation State Unit Sales</span>
                <span class="number">1997</span> Q1      USA    OR    xxx
                <span class="number">1997</span> Q1      USA    WA    xxx
                <span class="number">1997</span> Q2      USA    OR    xxx
                <span class="number">1997</span> Q2      USA    WA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Quarter=</span>any, <span class="variable">Nation=</span>USA, <span class="variable">State=</span>{OR, WA}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/04/mondrian-source-code-9/" data-id="ci833f3bu00121ggockd8ejtd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/04/mondrian-source-code-8/" class="article-date">
  <time datetime="2015-04-04T10:07:17.000Z" itemprop="datePublished">4月 4 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/04/mondrian-source-code-8/">mondrian 源码解读（八）-计算结果</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一节我们了解了member的查询过程。下面，我们将进入mdx的执行过程。</p>
<p>首先，我们需要了解3个重要的类，结果集RolapResult，求值上下文RolapEvaluator与单元格读取CellReader。这3个类的关系是首先由在RolapResult初始化构造函数中传入一个Query，由Query生成一个RolapEvaluator，然后由Query中的Calc根据RolapEvaluator来获取轴上的成员。获取到所有的成员之后，RolapEvaluator根据成员调用CellReader获取到当前值。</p>
<h2 id="RolapResult">RolapResult</h2><p>RolapResult是一个运行中的请求的结果集。</p>
<p>Mondiran的执行结果由RolapResult类表单，由于mdx查询语句本身就包含on rows(行轴上)、on columns（列轴上）和where部分（切片轴上），结果集中相对应的为ROlapAxis对象，这其中有个sliceAxis对象。因此结果集是由若干ROlapAxis对象和一个RolapCell组构成的。每个axis对象又由若干Position对象组成，每个Position对象又可能由若干member组成（注意一个postion会横跨多个维度的成员）。注意ROlapAxis是抽象类，实际的对象类可能随着不同的轴是不同的。如图：<br><img src="/img/mondrian_result.png" alt=""></p>
<p>图中，column轴上两个position(每个position含有一个成员)，分别是:</p>
<pre><code> [[Measures].[YJD]]
[[Measures].[GCLC]]
</code></pre><p>Row轴上有三个position(每个position含有二个成员)，分别是:</p>
<pre><code>[[dimLX].[All dimLXs], [dimTime].[All dimTimes]]
[[dimLX].[All dimLXs].[宁波—梁辉], [dimTime].[All dimTimes]]
[[dimLX].[All dimLXs].[同江－三亚], [dimTime].[All dimTimes]]
</code></pre><p>切片轴上则有一个position：</p>
<pre><code>[[dimStation].[All dimStations].[宁波市]]
</code></pre><p>单元值们则放置在RolapResult中的cellInfos对象里，属CellInfoContainer接口，其中存放着CellInfo，并通过Cellkey进行索引。</p>
<p>CellKey：用于在maps里访问cellinfo时使用的键值，根据cell的位置来决定键值。CellKey共有四个默认实现，及zero、one、two、three和many版的实现，分别对应着轴的个数。这些类中关键的属性便是存储各轴的位置值。</p>
<p>CellInfo、CellInfoContainer：内部类。CellInfo包含了一个cell所需要的所有信息(最关键的包含value值和一些formatter设置);最终将作为构造ROlapCell对象的参数。CellInfoContainer显然是cellInfo的容器，并使用CellKey来索引。</p>
<p>ROlapCell：最终返回给jpivot的cell单元值。</p>
<h2 id="RolapEvaluator">RolapEvaluator</h2><p>RolapEvaluator即在多维环境中计算表达式。<br>该类中维护一个很重要的对象，即currentMembers,该上下文对象针对每个维度都包含了一个成员；通过setContext方法用来设置当前维度，以开始计算当前维度组合下的表达式值。</p>
<p>该类有一个方法：<br><code>public final Object evaluateCurrent()</code><br>该方法就是对单元格的求值，在该方法中，规定了solver order的求解顺序。</p>
<h2 id="CellReader">CellReader</h2><p>CellReader即单元格读取。</p>
<p>Cells会被求值多次。第一次时, Evaluator使用FastBatchingCellReader来求值。当一个单元被求值时，evaluateCurrent()被调用。此时FastBatchingCellReader并没有被调用，而是为那个cell记录了一个 CellRequest并且return (not throw) an exception。在所有的cells都有了对应的CellRequests之后， Aggregation会生成 SQL，以一个单独的sql请求来载入所有的cells。然后由AggregatingCellReader 重新计算cells，从缓存中返回cells值。<br><img src="/img/CellReader.gif" alt=""></p>
<h3 id="FastBatchingCellReader">FastBatchingCellReader</h3><p>主要方法，Object get(Evaluator  evaluator)</p>
<ol>
<li>首先根据当前的上下文环境（即一组members）创建cellRequest，cellRequest中包含了所有必要的从star中取值的信息。该组members的交集便是要求值的单元格，其中切片轴上的成员和其他轴上的成员完全同等对待；其中度量轴上的成员要求上StoredMeasure（非计算成员CaculatedMember）；度量值上的成员位于第一个。通过调用request的addConstrainedColumn()方法把各member对应的column和value（属StarColumnPredicate）值加至到request中.</li>
<li>调用AggregationManager.getCellFromCache(request,pinnedSegments)方法从缓存中获取cell值。首先根据request中的列组索引标识从缓存中获取aggreation缓存对象，如果为空说明缓存还未建立则直接返回null，如果有值则调用aggregation.getCellValue(measure,colValueKeys)方法获取缓存的cell值；getCellValue内部首先会根据measure查找匹配的segment，然后调用segment.getCellValue(keys)从segment的dataset缓存集中查找相应的cell值。</li>
<li>如果getCellFromCache返回为null则调用recordCellRequest（）记录需求。这些cell request会被组织成多个cell request batch，以便将来聚合层进行批读取以提高效率。关于batch的详细讨论参见下面Batch类章节。</li>
<li>上层会在适当的时候调用batchCellReading.loadAggregations()以实际读取这些cell值，前提是batches对象中已有cellRequest了。每个batch的读取参见batch. loadAggregation()方法，最终调用聚合层的方法，参见aggreation.load(….)。</li>
</ol>
<h3 id="FastBatchingCellReader-Batch类">FastBatchingCellReader.Batch类</h3><p>每个batch对应与一组特定的columns环境下的cell求取（具有相同的列和列值(列值是具体的值，不会是“all”值)）；从batch的属性可以看出batch包含了哪些上下文：</p>
<ol>
<li>RolapStar.Column[]，这个指明了基于哪些列(也即基于哪些维度，包括切片维度)进行读取；</li>
<li>Set<starcolumnpredicate>[]，保存了每列的限定值，对于一列而言，限定值可能会有多个（毕竟是批处理，一次请求多个）；</starcolumnpredicate></li>
<li>MeasureList，指明求取哪些度量值上的cell（度量值本质是度量维上的限定值）。</li>
<li>BitKey，该batch的唯一索引。<br>如图所示的一个mdx查询结果界面：<br><img src="/img/fasterBatch.png" alt=""></li>
</ol>
<p>此时会产生两个batch，每个batch最终可能会产生若干segment，segment是cells的集合，</p>
<ol>
<li><p>一个batch是(其中“当量数/适应交通量=拥挤度”，拥挤度是计算成员)，最终产生3个segment，每个segment只有一个cell：</p>
<p>  （地市=’宁波市’,measure=’观察里程’）    </p>
<pre><code><span class="attribute">（地市</span>=<span class="string">’宁波市’,measure=’当量数’）</span>
</code></pre><p>  （地市=’宁波市’,measure=’适应交通量’）</p>
</li>
<li><p>另一个batch是(其中的G310等是路线代码，最终过滤掉空值后就剩下两个了) ，最终产生3个segment，每个segment有多个cell：</p>
<pre><code>（地市=’宁波市’,roadId <span class="keyword">in</span> (G310,G322,G210,S321….)，<span class="variable">measure=</span>’观察里程’）
（地市=’宁波市’,roadId <span class="keyword">in</span> (G310,G322,G210,S321….)，<span class="variable">measure=</span>’当量数’） 
（地市=’宁波市’,roadId <span class="keyword">in</span> (G310,G322,G210,S321….)，<span class="variable">measure=</span>’适应交通量’）
</code></pre></li>
</ol>
<p>此次：mdx的执行过程就分析完了。<br>ps：最后这一点来源于网络，由于从文档上无法得知作者来源，如有侵权还望见谅。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/04/mondrian-source-code-8/" data-id="ci833f3by00161ggooqjkzb87" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oracle-group-by" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/31/oracle-group-by/" class="article-date">
  <time datetime="2015-03-31T09:45:27.000Z" itemprop="datePublished">3月 31 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/31/oracle-group-by/">Oracle rollup、cube、grouping sets</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Oracle的group by除了基本用法以外，还有3种扩展用法，分别是rollup、cube、grouping sets。</p>
<h2 id="1_rollup">1 rollup</h2><p>假设有一个表test，有A、B、C、D、E5列。<br>如果使用group by rollup(A,B,C)，首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。roll up的意思是“卷起”，这也可以帮助我们理解group by rollup就是对选择的列从右到左以一次少一列的方式进行grouping直到所有列都去掉后的grouping(也就是全表grouping)，对于n个参数的rollup，有n+1次的grouping。以下2个sql的结果集是一样的：</p>
<p><code>Select A,B,C,sum(E) from test group by rollup(A,B,C)</code><br>与</p>
<p><code>Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,null,null,sum(E) from test</code></p>
<h2 id="2_cube">2 cube</h2><p>cube的意思是立方，对cube的每个参数，都可以理解为取值为参与grouping和不参与grouping两个值的一个维度，然后所有维度取值组合的集合就是grouping的集合，对于n个参数的cube，有2^n次的grouping。如果使用group by cube(A,B,C),，则首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作，一共是2^3=8次grouping。同rollup一样，也可以用基本的group by加上结果集的union all写出一个与group by cube结果集相同的sql：<br><code>Select A,B,C,sum(E) from test group by cube(A,B,C);</code><br>与<br><code>Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,C,sum(E) from test group by A,C
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,B,C,sum(E) from test group by B,C
union all
Select null,B,null,sum(E) from test group by B
union all
Select null,null,C,sum(E) from test group by C
union all
Select null,null,null,sum(E) from test;</code></p>
<h2 id="3_grouping_sets">3 grouping sets</h2><p>grouping sets就是对参数中的每个参数做grouping，也就是有几个参数做几次grouping,例如使用<code>group by grouping sets(A,B,C)</code>，则对(A),(B),(C)进行group by，如果使用<code>group by grouping sets((A,B),C)</code>,则对(A,B),(C)进行group by。甚至<code>grouping by grouping set(A,A)</code>都是语法允许的，也就是对(A)进行2次group by,grouping sets的参数允许重复</p>
<h2 id="4_总结">4 总结</h2><ul>
<li>rollup        (N+1个分组方案)</li>
<li>cube         (2^N个分组方案)</li>
<li>grouping sets (自定义罗列出分组方案)</li>
</ul>
<hr>
<h2 id="5_注意点">5 注意点</h2><h3 id="5-1_机制不同">5.1 机制不同</h3><p>在rollup和cube的说明中分别给出了用基本group by加结果集union all给出了结果集相同的sql，但这只是为了理解的方便而给出的sql，并不说明rollup和cube与基本group by加结果集union all等价。实际上两者的内部机制是安全不一样的，前者除了写法简洁以外，运行时不需多次扫描表，效率远比后者高。</p>
<h3 id="5-2_集合可运算">5.2 集合可运算</h3><p>3种扩展用法的参数可以是源表中的某一个具体的列，也可以是若干列经过计算而形成的一个新列（比如说A+B，A||B），也可以是这两种列的一个集合（例如（A+B，C）），对于grouping set更是特殊，可以是空集合()，表示对全表进行group by。</p>
<h3 id="5-3_group_by_与_rollup,_cube组合使用">5.3 group by 与 rollup, cube组合使用</h3><p>Group by的基本用法以及这3种扩展用法可以组合使用，也就是说可以出现group by A,rollup(A,B)这样的用法，oracle将对出现在group by中的每种用法的grouping列集合做笛卡尔积然后对其中的每一个元素做group by。这话说起来挺绕口，举例说明吧，group by A, rollup(A,B)，基本用法的grouping集合是(A),rollup(A,B)的grouping集合是((A,B),(A),()),两个集合的笛卡尔积集合是((A,A,B),(A,A),(A))，所以会首先对(A,A,B)做group by，然后对(A,A)做group by，最后对(A)做group by。实际上对(A,A,B)做group by和对(A,B)做group by两者是完全等价的(group by A,A,B结果和group by A,B完全一样)，同理对(A,A)做group by和对(A)做group by也是等价的。简化后的结果就是首先对(A,B)做group by，然后对(A)做group by，最后再对(A)做group by。下面给出两个等价的sql以便理解：<br><code>Select A,B,sum(E) from test1 group by A, rollup(A,B);</code><br>与<br><code>Select A,B,sum(E) from test1 group by A,B
Union all
Select A,null,sum(E) from test1 group by A
Union all
Select A,null,sum(E) from test1 group by A;</code></p>
<h2 id="6_grouping()、grouping_id()、group_id()">6 grouping()、grouping_id()、group_id()</h2><h3 id="6-1_grouping()">6.1 grouping()</h3><p>参数只有一个，而且必须为group by中出现的某一列，表示结果集的一行是否对该列做了grouping。对于对该列做了grouping的行而言，grouping()=0，反之为1；</p>
<h3 id="6-2_grouping_id()">6.2 grouping_id()</h3><p>参数可以是多个，但必须为group by中出现的列。Grouping_id()的返回值其实就是参数中的每列的grouping()值的二进制向量，例如如果grouping(A)=1，grouping(B)=0，则grouping_id(A,B)的返回值就是二进制的10，转成10进制就是2。</p>
<h3 id="6-3_group_id()">6.3 group_id()</h3><p>无参数。见上面的说明3），group by对某些列的集合会进行重复的grouping，而实际上绝大多数情况下对结果集中的这些重复行是不需要的，那就必须有办法剔出这些重复grouping的行。当结果集中有n条重复grouping而形成的行时，每行的group_id()分别是0,1,…,n，这样我们在条件中加入一个group_id()&lt;1就可以剔出这些重复grouping的行了。</p>
<h2 id="7_示例">7 示例</h2><h3 id="7-1_建表与数据">7.1 建表与数据</h3><p>SQL&gt; <code>create table test(department_id number, a varchar2(20), b varchar2(20));</code></p>
<p>Table created</p>
<p>SQL&gt; <code>insert into test values(10, &#39;A&#39;, &#39;B&#39;);</code></p>
<p>1 row inserted</p>
<p>SQL&gt; <code>commit;</code></p>
<p>Commit complete</p>
<h3 id="7-2_查询语句">7.2 查询语句</h3><p><code>select department_id,
       a,
       b,
       grouping(department_id),
       grouping(a),
       grouping(b)
  from test
 group by rollup(department_id, a, b)
order by 4, 5, 6;
select department_id,
       a,
       b,
       grouping(department_id),
       grouping(a),
       grouping(b)
  from test
 group by cube(department_id, a, b)
order by 4, 5, 6;</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/03/31/oracle-group-by/" data-id="ci833f3bq000v1ggoyf9fhl4p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/groupby/">groupby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oralce/">oralce</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-ext-function执行机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/13/mondrian-ext-function执行机制/" class="article-date">
  <time datetime="2014-11-13T10:07:10.000Z" itemprop="datePublished">11月 13 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/13/mondrian-ext-function执行机制/">mondrian 源码解读（番外篇）-MDX函数的执行过程详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MDX函数的执行过程详解">MDX函数的执行过程详解</h2><p>笔者注：由于将来公司可能会有对函数的二次开发需求，所以为公司写了函数的执行过程，以供将来使用。</p>
<h3 id="一，Query对象的创建">一，Query对象的创建</h3><p>在Query对象中，最主要的是resolve()方法，这里涉及到了2个非常重要的功能。</p>
<ul>
<li><p>第一，轴（查询轴和切片轴）上表达式(Exp)的转换。</p>
<p>  主要是将表达式从UnresolvedFunCall转换为ResolvedFunCall。</p>
</li>
<li><p>第二，轴上的计算器(Calc)的创建。</p>
<p>  主要是针对各个轴如何创建计算器。</p>
</li>
</ul>
<p>下面是的resolve()方法解释：</p>
<pre><code> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">()</span> </span>{
    <span class="keyword">final</span> Validator validator = createValidator(); <span class="comment">//1</span>
    resolve(validator); <span class="comment">// resolve self and children ,2</span>
    <span class="comment">// Create a dummy result so we can use its evaluator</span>
    <span class="keyword">final</span> Evaluator evaluator = Util.createEvaluator(<span class="keyword">this</span>); <span class="comment">//3</span>
    ExpCompiler compiler =
            createCompiler(
                    evaluator, validator, Collections.singletonList(resultStyle)); <span class="comment">//4</span>
    compile(compiler);  <span class="comment">//5</span>
}
</code></pre><ol>
<li>第1行创建校验器(Validator)。</li>
<li>第2行根据Validator转换所有的UnresolvedFunCall到ResolvedFunCall。</li>
<li>第3行针对当前Query创建求值器(Evaluator)。</li>
<li>第4行根据求值器，校验器创建表达式编译器(ExpCompiler)。</li>
<li>第5行根据表达式编译器编译所有的轴，并创建轴上的计算器。</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2014/11/13/mondrian-ext-function执行机制/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/11/13/mondrian-ext-function执行机制/" data-id="ci833f3cn001u1ggoancktbb5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/02/mondrian-source-code-7/" class="article-date">
  <time datetime="2014-11-02T10:07:10.000Z" itemprop="datePublished">11月 2 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/02/mondrian-source-code-7/">mondrian 源码解读（七）-读取member</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面几节中我们了解了cube的创建和query的创建。有了这2样东西后，我们就可以开始执行mdx语句了。在第二小节中，我们了解了mdx的执行顺序。</p>
<ol>
<li>先执行from，即表示从哪个cube中获取结果。</li>
<li>再执行where，with和axis，即获取member阶段。</li>
<li>有了所有依赖的成员后，最后执行Cell的值。</li>
</ol>
<p>cube的创建已经在前一节中讲过了，接着是member获取阶段，由于这一阶段分为3部分，内容比较多。所以下面我们先将member是如何读取的，后几节再介绍它的执行过程。</p>
<h2 id="MemberSource">MemberSource</h2><p>所有对成员的读取操作都是通过MemberSource来完成的。<br>MemberSource基本功能就是是读取层次的成员操作。<br>我们看下它的基本接口：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberSource</span> </span>{

    <span class="function">RolapHierarchy <span class="title">getHierarchy</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">boolean</span> <span class="title">setCache</span><span class="params">(MemberCache cache)</span></span>;

    <span class="function">List&lt;RolapMember&gt; <span class="title">getMembers</span><span class="params">()</span></span>;

    <span class="function">List&lt;RolapMember&gt; <span class="title">getRootMembers</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">getMemberChildren</span><span class="params">(
        RolapMember parentMember,
        List&lt;RolapMember&gt; children)</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">getMemberChildren</span><span class="params">(
        List&lt;RolapMember&gt; parentMembers,
        List&lt;RolapMember&gt; children)</span></span>;

    <span class="function"><span class="keyword">int</span> <span class="title">getMemberCount</span><span class="params">()</span></span>;

    <span class="function">RolapMember <span class="title">lookupMember</span><span class="params">(
        List&lt;Id.Segment&gt; uniqueNameParts,
        <span class="keyword">boolean</span> failIfNotFound)</span></span>;
}    
</code></pre><p>从上面我们可以看到，有3个最基本的接口，分别是获取层次，即当前的MemberSource属于哪个层次，设置缓存对象（为了从缓存中读取member），和获得当前层次的成员。这就是MemberSource的核心功能。</p>
<h2 id="MemberReader">MemberReader</h2><p>我们先看MemberReader的层次图。<br><img src="/img/QQ图片20141102182120.jpg" alt=""><br>从上图中我们看到，MemberReader是继承的MemberSource，所以MemberReader具有MemberSource所有的功能。那么它有哪些功能呢？<br>我们看看它的接口:</p>
<pre><code><span class="class"><span class="keyword">interface</span> <span class="title">MemberReader</span> <span class="keyword">extends</span> <span class="title">MemberSource</span> </span>{

    <span class="function">RolapMember <span class="title">getLeadMember</span><span class="params">(RolapMember member, <span class="keyword">int</span> n)</span></span>;


    <span class="function">List&lt;RolapMember&gt; <span class="title">getMembersInLevel</span><span class="params">(
        RolapLevel level)</span></span>;


    <span class="function"><span class="keyword">void</span> <span class="title">getMemberRange</span><span class="params">(
        RolapLevel level,
        RolapMember startMember,
        RolapMember endMember,
        List&lt;RolapMember&gt; list)</span></span>;

    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(
        RolapMember m1,
        RolapMember m2,
        <span class="keyword">boolean</span> siblingsAreEqual)</span></span>;

    Map&lt;? extends Member, Access&gt; getMemberChildren(
        RolapMember member,
        List&lt;RolapMember&gt; children,
        MemberChildrenConstraint constraint);

    Map&lt;? extends Member, Access&gt; getMemberChildren(
        List&lt;RolapMember&gt; parentMembers,
        List&lt;RolapMember&gt; children,
        MemberChildrenConstraint constraint);

    <span class="function">List&lt;RolapMember&gt; <span class="title">getMembersInLevel</span><span class="params">(
        RolapLevel level,
        TupleConstraint constraint)</span></span>;

    <span class="function"><span class="keyword">int</span> <span class="title">getLevelMemberCount</span><span class="params">(RolapLevel level)</span></span>;

    <span class="function">MemberBuilder <span class="title">getMemberBuilder</span><span class="params">()</span></span>;

    <span class="function">RolapMember <span class="title">getDefaultMember</span><span class="params">()</span></span>;

    <span class="function">RolapMember <span class="title">getMemberParent</span><span class="params">(RolapMember member)</span></span>;

    <span class="function">RolapMember <span class="title">substitute</span><span class="params">(RolapMember member)</span></span>;

    <span class="function">RolapMember <span class="title">desubstitute</span><span class="params">(RolapMember member)</span></span>;

    <span class="function">RolapMember <span class="title">getMemberByKey</span><span class="params">(
        RolapLevel level,
        List&lt;Comparable&gt; keyValues)</span></span>;
}
</code></pre><p>从上面大家发现没，MemberReader更细化功能，它可以获取到Level上的成员，也可以获取成员的父成员或者成员的子成员，并且在获取成员的时候可以添加约束条件。有了这些功能，我们就可以任意的获取成员了，所以MemberReader是成员获取的主接口。</p>
<h2 id="具体实现">具体实现</h2><h3 id="SmartMemberReader">SmartMemberReader</h3><p>SmartMemberReader实现了MemberReader接口，它实现了维度成员及其子成员的缓存，如果有一个成员位于缓存中，则还会有一个其子成员的列表。它同时缓存了level下的成员们。该类主要的成员有：</p>
<ul>
<li>source：MemberReader，用于实际从数据库中读取维度成员值。</li>
<li>mapMemberToChildren：map，实现成员及其子成员的映射， key为RolapMember，value为List<rolapmember>。</rolapmember></li>
<li>mapKeyToMember： map ，实现所有成员的缓存，其中的key为MmberKey</li>
<li>mapLevelToMembers: map，实现级别及其所有成员的映射， key为RolapLevel，value为List<rolapmember>。</rolapmember></li>
</ul>
<h3 id="SqlMemberSource">SqlMemberSource</h3><p>SqlMemberSource是最终更数据库打交道的类，它会针对要查询对Level生成一个sql，该sql最终通过数据库执行，将查询结果返回后拼装成member。需要注意的一点是，如果该member有parentmember，必须要生成其对应的parentmember。生成过程即先递归的在level中查找其上一级level的member是否缓存，如果没有缓存，则将其加入查询列表中，直到上一级为空或缓存了member。找到所有要查询的level后，最后一次性生成sql向数据库查询数据。</p>
<p>SmartMemberReader的source其实为mondrian.rolap.SqlMemberSource类，该类中反过来又存储了SmartMemberReader对象，作为其cache成员属性。成员读取过程：</p>
<ol>
<li>smartMemberReader.getMemberChildren(parentMembers,children,constrain);</li>
<li>最终通过source.getMemberChildren()…，其中反过来会把找到的children赋予mapKeyToMember。</li>
<li>最终除了将结果返回在children输出参数中，同时也对mapMemberToChildren赋值了。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/11/02/mondrian-source-code-7/" data-id="ci833f3c000191ggogpwlfaw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/mondrian-source-code-6/" class="article-date">
  <time datetime="2014-10-26T10:07:05.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/mondrian-source-code-6/">mondrian 源码解读（六）-创建CUBE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在第4节中，构建query的时候，有一个非常重要的东西被我忽略了，那就是构建cube <code>Util.lookupCube(statement.getSchemaReader(), cube, true)</code>，下面我们来谈谈cube是如何构建的。</p>
<h2 id="Cube是什么？">Cube是什么？</h2><p>在第2节中，我们已经谈论了cube，即维度和度量的组合。</p>
<h2 id="RolapCube">RolapCube</h2><p>在理解了Cube后，我们就可以理解RolapCube了。根据字面意思，我们也可以理解为关系型联机分析处理cube。我们看看它里面主要是实体对象：</p>
<pre><code><span class="comment">//不解释</span>
<span class="keyword">protected</span> Dimension[] dimensions;

<span class="comment">//</span>
<span class="keyword">private</span> <span class="keyword">final</span> RolapHierarchy measuresHierarchy;

<span class="comment">/**
 * List of calculated members.
 * 定义在schema中的计算成员，注意公式是如何转换的呢？
 */</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Formula&gt; calculatedMemberList = <span class="keyword">new</span> ArrayList&lt;Formula&gt;();

<span class="keyword">private</span> RolapStar star; <span class="comment">//关联的星型模型</span>

<span class="comment">//在Evaluator中用于计算当前成员是否为空，如果当前度量成员中有count聚合，即为当前成员，如果没有找到，创建一个虚拟的count聚合为测量的成员。</span>
RolapBaseCubeMeasure factCountMeasure;
</code></pre><p>calculatedMemberList这里谈一下。如何将schema中定义的计算成员转换成已近解析好的Formula？<br>这里其实很简单，通过构造一个特定的mdx：<br><code>with member [Measures].[aa] as &#39;expression1&#39; ,
[Measures].[bb] as &#39;expression2&#39;select from cube</code><br>然后使用parser解析器解析mdx后返回一个query，query里面的计算成员即为此计算成员。</p>
<h2 id="RolapStar是什么？">RolapStar是什么？</h2><p>我们可以将它理解为一个关联了物理表之间的关系的对象。通过它来生成特定的sql，查询需要的数据。<br>具体实体对象大家可以打开看看，这里不做详细的解释了。</p>
<pre><code><span class="keyword">private</span> DataSource dataSource;
<span class="keyword">private</span> <span class="keyword">final</span> Table factTable;
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Column&gt; columnList = <span class="keyword">new</span> ArrayList&lt;Column&gt;();

Table对象..星型模型
<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> RolapStar star;
    <span class="keyword">private</span> <span class="keyword">final</span> MondrianDef.Relation relation;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Column&gt; columnList;
    <span class="keyword">private</span> <span class="keyword">final</span> Table <span class="keyword">parent</span>;
    <span class="keyword">private</span> <span class="keyword">List</span>&lt;Table&gt; children;
    <span class="keyword">private</span> <span class="keyword">final</span> Condition joinCondition;
    <span class="keyword">private</span> <span class="keyword">final</span> String alias;
}
</code></pre><h2 id="源码修改">源码修改</h2><p>cube的创建是根据schema中定义的属性配置来创建cube，这部分没有细看，如何创建其实我们并不关系，理解cube的数据结构就行了。</p>
<p>我们在修改mondrian源码时，将cube创建这块全部去掉了，取而代之的使用了自己的cube创建方式。由于我们底层的存储结构不依赖与xml，而是我们自己定义好的实体间的关系，所以我们将我们的实体转换成了cube。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/10/26/mondrian-source-code-6/" data-id="ci833f3c6001c1ggokyhalqii" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/mondrian-source-code-5/" class="article-date">
  <time datetime="2014-10-26T08:06:12.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/mondrian-source-code-5/">mondrian 源码解读（五）-访问者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上一节中，我们看到在resolve()方法中使用了大量的访问者模式，所以下面我们总结下：</p>
<h2 id="什么是访问者模式">什么是访问者模式</h2><p>我发现还是GOF书中定义的最好，就拿过来了。</p>
<h3 id="意图">意图</h3><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提<br>下定义作用于这些元素的新操作。</p>
<h3 id="结构图">结构图</h3><p><img src="/img/QQ图片20141026172247.jpg" alt=""><br>
        
          <p class="article-more-link">
            <a href="/2014/10/26/mondrian-source-code-5/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/10/26/mondrian-source-code-5/" data-id="ci833f3c8001f1ggosrdugk78" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/mondrian-source-code-4/" class="article-date">
  <time datetime="2014-10-26T05:27:33.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/mondrian-source-code-4/">mondrian 源码解读（四）-从parser开始</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面几节我们介绍了一下mondrian最基础的东西，只有在了解了这些后，我们才能继续往下看。</p>
<p>首先，mondrian需要将mdx语句解析成java对象，我们先看看他是如何解析的。</p>
<h2 id="Query创建过程">Query创建过程</h2><p>我们从ConnectionBase的parser开始，在parseStatement中，有一句很重要的话语句。</p>
<pre><code>public <span class="keyword">Query</span> parseQuery(String <span class="keyword">query</span>) {
    <span class="keyword">return</span> (<span class="keyword">Query</span>) parseStatement(<span class="keyword">query</span>);
}

<span class="keyword">Query</span> parseStatement(...){
...
<span class="keyword">return</span> parser.parseInternal(
                statement, <span class="keyword">query</span>, debug, funTable, strictValidation);
...
}
</code></pre><h3 id="一，创建解析器">一，创建解析器</h3><p>首先，我们需要一个parser。在ConnectionBase类中，我们看到了parser的创建过程：</p>
<pre><code><span class="keyword">protected</span> <span class="function">MdxParserValidator <span class="title">createParser</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">true</span>
        ? <span class="keyword">new</span> JavaccParserValidatorImpl()
        : <span class="keyword">new</span> MdxParserValidatorImpl();
}
</code></pre><p>实际上，由于这里永远是true，所以返回的是JavaccParserValidatorImpl。这个类也是实现了MdxParserValidator。它与原生的javaccparser生成的MdxParserValidatorImpl的主要不同在于factory的创建方式和异常的处理方式，这里就不做过多解读了，具体请看源代码。
        
          <p class="article-more-link">
            <a href="/2014/10/26/mondrian-source-code-4/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/10/26/mondrian-source-code-4/" data-id="ci833f3cb001i1ggosf43io0q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/mondrian-source-code-3/" class="article-date">
  <time datetime="2014-10-26T04:12:55.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/mondrian-source-code-3/">mondrian 源码解读（三）-mondrian架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mondrian系统的层次">mondrian系统的层次</h2><p>mondrian总共包含四个层次：表示层,计算层,聚集层,存储层.。</p>
<h3 id="表示层(presentation_layer)">表示层(presentation layer)</h3><p>指最终呈现在用户显示器上的,以及与用户之间的交互,有许多方法来展现多维数据,包括数据透视表,饼,柱,线状图. </p>
<h3 id="计算层(dimensional_layer)">计算层(dimensional layer)</h3><p>分析,验证,执行MDX查询. 一个mdx查询语句会有多个处理阶段。先是计算轴，然后是轴上的单元值。为效率起见，计算层批量将单元请求发送到聚集层。请求转换器允许程序操作存在的请求，而不是为每个请求从头构造mdx请求。元数据描述了计算模型和它怎么匹配到关系模型。</p>
<h3 id="聚集层(star_layer)">聚集层(star layer)</h3><p>一个聚集指内存中一组计算值(cell),这些值通过维列来限制.计算层发送单元请求,如果请求不在缓存中,或者不能通过旋转聚集导出的话,聚集层向存储层发送请求. 聚集层是一个数据缓冲层(cache)<br>从数据库来的单元数据，聚合后提供给计算层。聚集层的主要作用是提高系统的性能。 </p>
<h3 id="存储层(storage_layer)">存储层(storage layer)</h3><p>提供聚集单元数据(cell)和维表的成员(member),这些层可以不在同一机子上,但是计算和聚集层必须在同一台机子上。有三种需要存储的数据：事实数据(事实表)、维度表和聚集数据(即聚合表)</p>
<p><img src="/img/arch_mondrian_v1_lrg.png" alt="架构图"></p>
<p>更多内容请移步：<a href="http://mondrian.pentaho.com/documentation/architecture.php" target="_blank" rel="external">http://mondrian.pentaho.com/documentation/architecture.php</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/10/26/mondrian-source-code-3/" data-id="ci833f3cd001l1ggoazae2oa8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/26/mondrian-source-code-2/" class="article-date">
  <time datetime="2014-10-26T04:11:20.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/mondrian-source-code-2/">mondrian 源码解读（二）-MDX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是MDX？">什么是MDX？</h2><p>MDX为MultiDimensional Expressions的缩写，多维表达式，是标准的OLAP查询语言。在多数OLAPServer都提供MDX支持，如Microsoft SQL Server OLAP Services,SAS,Hyperion Essbase等。</p>
<p>支持多维对象与数据的定义和操作。MDX 在很多方面与结构化查询语言 (SQL) 语法相似，但它不是 SQL 语言的扩展；事实上，MDX 所提供的一些功能也可由 SQL 提供，尽管不是那么有效或直观。<br>如同 SQL 查询一样，每个 MDX 查询都要求有数据请求（SELECT 子句）、起始点（FROM 子句）和筛选（WHERE 子句）。这些关键字以及其它关键字提供了各种工具，用来从多维数据集析取数据的特定部分。</p>
<p>MDX 还提供了可靠的函数集，用来对所检索的数据进行操作，同时还具有用户定义函数扩展 MDX 的能力。MDX为多维数据库提供了表达式查询语法，用于查询Cube数据，并提供了许多强大的分析函数，用于支持常用的OLAP分析。
        
          <p class="article-more-link">
            <a href="/2014/10/26/mondrian-source-code-2/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2014/10/26/mondrian-source-code-2/" data-id="ci833f3cg001o1ggo2a5j71d4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/public/_posts/page/2/">2</a><a class="page-number" href="/public/_posts/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/public/_posts/page/5/">5</a><a class="extend next" rel="next" href="/public/_posts/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机原理/">计算机原理</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/antlr4/">antlr4</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aop/">aop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exception/">exception</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/groupby/">groupby</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/">idea</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/impala/">impala</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/">jdbc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk/">jdk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mondrian/">mondrian</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oralce/">oralce</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plan/">plan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tx/">tx</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列式/">列式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串替换/">字符串替换</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储/">存储</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境变量/">环境变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机原理/">计算机原理</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 18px;">android</a><a href="/tags/antlr4/" style="font-size: 20px;">antlr4</a><a href="/tags/aop/" style="font-size: 10px;">aop</a><a href="/tags/exception/" style="font-size: 12px;">exception</a><a href="/tags/groupby/" style="font-size: 10px;">groupby</a><a href="/tags/hadoop/" style="font-size: 12px;">hadoop</a><a href="/tags/idea/" style="font-size: 10px;">idea</a><a href="/tags/impala/" style="font-size: 10px;">impala</a><a href="/tags/jdbc/" style="font-size: 10px;">jdbc</a><a href="/tags/jdk/" style="font-size: 10px;">jdk</a><a href="/tags/linux/" style="font-size: 14px;">linux</a><a href="/tags/mondrian/" style="font-size: 20px;">mondrian</a><a href="/tags/oralce/" style="font-size: 10px;">oralce</a><a href="/tags/plan/" style="font-size: 10px;">plan</a><a href="/tags/spring/" style="font-size: 16px;">spring</a><a href="/tags/tx/" style="font-size: 14px;">tx</a><a href="/tags/列式/" style="font-size: 10px;">列式</a><a href="/tags/字符串替换/" style="font-size: 10px;">字符串替换</a><a href="/tags/存储/" style="font-size: 10px;">存储</a><a href="/tags/源码/" style="font-size: 12px;">源码</a><a href="/tags/环境变量/" style="font-size: 10px;">环境变量</a><a href="/tags/计算机原理/" style="font-size: 10px;">计算机原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2015/04/">四月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/11/">十一月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/10/">十月 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/09/">九月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/08/">八月 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/06/">六月 2014</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/05/">五月 2014</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/04/04/mondrian-source-code-9/">mondrian 源码解读（九）-聚集层</a>
          </li>
        
          <li>
            <a href="/2015/04/04/mondrian-source-code-8/">mondrian 源码解读（八）-计算结果</a>
          </li>
        
          <li>
            <a href="/2015/03/31/oracle-group-by/">Oracle rollup、cube、grouping sets</a>
          </li>
        
          <li>
            <a href="/2014/11/13/mondrian-ext-function执行机制/">mondrian 源码解读（番外篇）-MDX函数的执行过程详解</a>
          </li>
        
          <li>
            <a href="/2014/11/02/mondrian-source-code-7/">mondrian 源码解读（七）-读取member</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 sqtds<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>