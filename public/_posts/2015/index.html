<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>蜻蜓点水</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="蜻蜓点水">
<meta property="og:url" content="http://sqtds.github.io/public/_posts/2015/index.html">
<meta property="og:site_name" content="蜻蜓点水">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蜻蜓点水">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="蜻蜓点水" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蜻蜓点水</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">if you never try , you will lost forever.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://sqtds.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-collections-uml" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/05/collections-uml/" class="article-date">
  <time datetime="2015-05-05T11:21:50.000Z" itemprop="datePublished">5月 5 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/collections-uml/">集合UML图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文只展现java.util下的集合类，供以后自己查看，不废话上图：</p>
<h2 id="集合大图模式">集合大图模式</h2><p><img src="/img/collections uml.png" alt="集合大图模式"></p>
<h2 id="集合方法">集合方法</h2><p><img src="/img/collection uml Method.png" alt="方法展现"></p>
<h2 id="并发集合大图模式">并发集合大图模式</h2><p><img src="/img/concurrent uml.png" alt="并发集合大图模式"></p>
<h2 id="并发集合方法">并发集合方法</h2><p><img src="/img/concurrent uml Method.png" alt="并发集合方法"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/05/05/collections-uml/" data-id="ci9b8x75m004cp8gol0kir5z1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/collections/">collections</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/j2se/">j2se</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/29/linux-command/" class="article-date">
  <time datetime="2015-04-29T08:35:07.000Z" itemprop="datePublished">4月 29 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="TOP命令">TOP命令</h3><p>对于多核CPU，显示的是多个CPU的所占的百分比的总和，如需要查看每个核的情况，进入top视图后按1，就会按核来显示消耗情况。<br>默认情况下，TOP视图中显示的是进程的CPU消耗情况，在TOP视图中，按shift+h后，可按线程查看CPU的消耗情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/29/linux-command/" data-id="ci9b8x74i0032p8goi5wdlqy5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-性能调优总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/27/性能调优总结/" class="article-date">
  <time datetime="2015-04-27T03:38:06.000Z" itemprop="datePublished">4月 27 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/性能/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/性能调优总结/">性能调优总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>性能调优主要是对CPU，磁盘IO，网络IO，内存等方面进行调优。<br><img src="/img/性能调优.png" alt="性能调优"></p>
<h2 id="一，CPU">一，CPU</h2><h3 id="1,上下文切换">1,上下文切换</h3><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程或线程切换到另一个进程或线程。</p>
<p>上下文是指某一时间点 CPU 寄存器和程序计数器的内容。寄存器是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p>
<p>稍微详细描述一下，上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动： </p>
<ol>
<li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，</li>
<li>在内存中检索下一个进程的上下文并 将其在 CPU 的寄存器中恢复，</li>
<li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</li>
</ol>
<p>上下文切换的消耗</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。<br>Linux 号称的相比于其他的操作系统（包括其他类 Unix 系统）的很多优点中，有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h3 id="2，利用率">2，利用率</h3><p>利用率为CPU在用户进程，内核，中断处理，IO等待以及空闲5个部分使用百分比。Linux And System Network Performance Monitoring建议用户进程和内核进程的CPU消耗分别是65%-70%，30%-35%。<br>在liunx中可以使用top或者pidstat查看CPU的消耗情况。<br>在java应用中，CPU消耗主要在us,sy上。</p>
<h4 id="US">US</h4><p><strong>US:用户进程处理所占的百分比</strong><br>当us过高时，表明应用消耗了大量的CPU。在这种情况下，需要找到具体消耗CPU的线程所执行的代码。</p>
<h4 id="SY">SY</h4><p><strong>SY：内核线程所占的百分比</strong><br>当sy过高时，表示linux花费了过多的时间在进程切换上面。java应用造成这种现象的主要原因是启动的线程比较多，且这些线程多数处于不断阻塞的状态和执行状态的变化过程中，产生了大量的上下文切换。<br>通过jstack -l pid 查看线程争用。可以看到TIMED_WAITING(on object monitor)状态和Runnable转换中。</p>
<h2 id="二，磁盘IO">二，磁盘IO</h2><p>在linux中，要查看线程的磁盘IO消耗，主要方法是通过pidstat。<br><img src="/img/QQ图片20150429165052.png" alt=""><br>使用pidstat找到文件IO操作多的线程，之后结合jstack找到对应的java代码。</p>
<h2 id="三，网络IO">三，网络IO</h2><p>在linux中，通过sar来分析网络IO的状况。如果需要跟踪tcp的通信信息，需要使用tcpdump来进行。</p>
<h2 id="四，内存消耗">四，内存消耗</h2><p>通过jmap，jstat，mat，visualVM来分析</p>
<p>PS:本文总结自《分布式JAVA应用 基础与实践》—-林昊</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/27/性能调优总结/" data-id="ci9b8x71w0006p8go9abq0ikz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能/">性能</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-string" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/26/java-string/" class="article-date">
  <time datetime="2015-04-26T04:02:33.000Z" itemprop="datePublished">4月 26 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/26/java-string/">String字符串小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>String可以说是java编程中最常用的对象。用了这么久，大家对它的印象有多深呢？下面我就谈谈我自己对它的一些认知吧。</p>
<h2 id="不可变对象">不可变对象</h2><p>我们可以看到，String被声明成了final,这样我们可以得到String是不可继承的对象，也是线程安全的对象。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>
<span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>{
    <span class="comment">/** The value is used for character storage. */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];

    <span class="comment">/** Cache the hash code for the string */</span>
    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span>
}
</code></pre><h3 id="concat">concat</h3><p>接下来我们看String的concat方法。由于String是不可变的，所以当我们连接一个字符串时，它会合并2哥字符串的value数组，然后用这个数组创建一个新的字符串。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">concat</span>(<span class="keyword">String</span> <span class="built_in">str</span>) {
    <span class="built_in">int</span> otherLen = <span class="built_in">str</span>.length();
    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    <span class="built_in">int</span> len = value.length;
    <span class="built_in">char</span> buf[] = Arrays.copyOf(value, len + otherLen);
    <span class="built_in">str</span>.getChars(buf, len);
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(buf, <span class="keyword">true</span>);
  }
</code></pre><h3 id="“+”连接符的处理">“+”连接符的处理</h3><p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。</p>
<pre><code><span class="keyword">String</span> str1 = <span class="string">"aabc0"</span>;
<span class="keyword">String</span> str2 = <span class="string">"aa"</span> + <span class="string">"bc"</span>+<span class="string">"0"</span>;
System.out.<span class="built_in">println</span>(str1+<span class="string">"  "</span>+str2);
System.out.<span class="built_in">println</span>(str1==str2);
<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) {
    <span class="keyword">String</span> str3 = <span class="string">"aa"</span> + <span class="string">"bc"</span>+i;
    System.out.<span class="built_in">println</span>(str1+<span class="string">"  "</span>+str3);
    System.out.<span class="built_in">println</span>(str1==str3);
}
</code></pre><p>打印结果：</p>
<pre><code><span class="title">aabc0</span>  aabc0
<span class="built_in">true</span>
aabc0  aabc0
<span class="built_in">false</span>
</code></pre><p>如果在编译期间就能确定字符串，编译器就会优化String，合并到一起。如上例所示str1==str2为true，表明为同一字符串。</p>
<h2 id="intern浅析">intern浅析</h2><p>对于字符串常量池，看了网上的很多文章，大部分人貌似都不对。现在在此在总结一遍。</p>
<pre><code><span class="keyword">String</span> str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"chaofan"</span>).<span class="built_in">append</span>(<span class="string">"wei"</span>).toString();
System.out.<span class="built_in">println</span>(str1.intern() == str1);

<span class="keyword">String</span> str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).<span class="built_in">append</span>(<span class="string">"va"</span>).toString();
System.out.<span class="built_in">println</span>(str2.intern() == str2);
</code></pre><p>打印结果：</p>
<pre><code><span class="title">jdk6</span> 下<span class="built_in">false</span> <span class="built_in">false</span>
jdk7 下<span class="built_in">true</span> <span class="built_in">false</span>
</code></pre><p>产生的差异在于在jdk1.6中 intern 方法会把首次遇到的字符串实例复制到永久待（常量池）中，并返回此引用；但在jdk1.7中，只是会把首次遇到的字符串实例的引用添加到常量池中（没有复制），并返回此引用。<br>所以在jdk1.7中执行上面代码，str1返回true是引用他们指向的都是str1对象（堆中）（池中不存在，返回原引用），而str2返回false是因为池中已经存在”java”了（关键词），所以返回的池的对象，因此不相等。</p>
<p>相信很多 JAVA 程序员都做做类似 String s = new String(“abc”)这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。接下来我们分析另一端代码。</p>
<pre><code><span class="keyword">String</span> s = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"1"</span>);
s.intern();
<span class="keyword">String</span> s2 = <span class="string">"1"</span>;
System.out.<span class="built_in">println</span>(s == s2);

<span class="keyword">String</span> s3 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"1"</span>);
s3.intern();
<span class="keyword">String</span> s4 = <span class="string">"11"</span>;
System.out.<span class="built_in">println</span>(s3 == s4);
</code></pre><p>打印结果是</p>
<ul>
<li>jdk6 下<code>false false</code></li>
<li>jdk7 下<code>false true</code></li>
</ul>
<p>为什么会这样呢？美团网给出了很好的解释？我觉得上面的说法比美团网的解释更好，大家可以参考<a href="http://tech.meituan.com/in_depth_understanding_string_intern.html。" target="_blank" rel="external">http://tech.meituan.com/in_depth_understanding_string_intern.html。</a><br>最根本的原因应该是:<br>jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
<ul>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li>String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ul>
<h3 id="intern需要注意的地方">intern需要注意的地方</h3><p>String的String Pool是一个固定大小的Hashtable，<strong>默认值大小长度是1009</strong>，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
<p>在 jdk6中StringTable是固定的，就是1009的长度，所以<strong>如果常量池中的字符串过多就会导致效率下降很快</strong>。在jdk7中，StringTable的长度可以通过一个参数指定：</p>
<ul>
<li>-XX:StringTableSize=99991</li>
</ul>
<p>例如：在fastjson 中对所有的 json 的 key 使用了 intern 方法，缓存到了字符串常量池中，这样每次读取的时候就会非常快，大大减少时间和空间。而且 json 的 key 通常都是不变的。这个地方没有考虑到大量的 json key 如果是变化的，那就会给字符串常量池带来很大的负担。</p>
<p>这个问题 fastjson 在1.1.24版本中已经将这个漏洞修复了。程序加入了一个最大的缓存大小，超过这个大小后就不会再往字符串常量池中放了。<br>更多详情请参考<a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">http://tech.meituan.com/in_depth_understanding_string_intern.html</a></p>
<h2 id="subString内存泄露">subString内存泄露</h2><p>首先我们看subString方法。</p>
<pre><code><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>{
    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);
    }
    <span class="keyword">int</span> subLen = <span class="keyword">value</span>.length - beginIndex;
    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);
    }
    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(<span class="keyword">value</span>, beginIndex, subLen);
}
</code></pre><p>在这个方法中，新建了一个String对象。</p>
<p>在jdk1.7,1.8中,如下：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> <span class="keyword">value</span>[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>{
     ....
    <span class="keyword">this</span>.<span class="keyword">value</span> = Arrays.copyOfRange(<span class="keyword">value</span>, offset, offset+count);
}
</code></pre><p>在jdk1.6中</p>
<pre><code>String(<span class="keyword">int</span> offset, <span class="keyword">int</span> <span class="keyword">count</span>, <span class="keyword">char</span> value[]) {
    <span class="keyword">this</span>.value = value;
    <span class="keyword">this</span>.offset = offset;
    <span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;
}
</code></pre><p>我们可以看到，1.6中还是引用了原来的字符串，存在内存泄露问题。1.7及以上使用了数组复制的方法创建了一个新的数组，不存在内存泄露。</p>
<h2 id="其他">其他</h2><h3 id="字符串分割">字符串分割</h3><p>在jdk1.6中：优先考虑使用indexOf方法，最后才使用spilt方法。<br>在jdk1.8中：优先考虑spilt方法，最后是indexOf方法。<br>为什么？我们对下面代码进行测试：</p>
<pre><code>StringBuffer sb = new StringBuffer<span class="list">()</span><span class="comment">;</span>
int i = <span class="number">1000</span><span class="comment">;</span>
for <span class="list">(<span class="keyword">int</span> i1 = i<span class="comment">; i1 &gt; 0; i1--) {</span>
    sb.append<span class="list">(<span class="keyword">i1</span>)</span>.append<span class="list">(<span class="string">";"</span>)</span><span class="comment">;</span>
}
String old = sb.toString<span class="list">()</span><span class="comment">;</span>
int k = <span class="number">10000</span><span class="comment">;</span>
long l = System.currentTimeMillis<span class="list">()</span><span class="comment">;</span>
for <span class="list">(<span class="keyword">int</span> k1 = k<span class="comment">; k1 &gt; 0; k1--) {</span>
    old.split<span class="list">(<span class="string">";"</span>)</span><span class="comment">;</span>
}
System.out.println<span class="list">(<span class="keyword">System</span>.currentTimeMillis<span class="list">()</span> - l)</span><span class="comment">;</span>
long l1 = System.currentTimeMillis<span class="list">()</span><span class="comment">;</span>
String tmp = old<span class="comment">;</span>
for <span class="list">(<span class="keyword">int</span> k1 = k<span class="comment">; k1 &gt; 0; k1--) {</span>
    while <span class="list">(<span class="keyword">true</span>)</span> {
        int j = tmp.indexOf<span class="list">(<span class="string">";"</span>)</span><span class="comment">;</span>
        if <span class="list">(<span class="keyword">j</span> &lt; <span class="number">0</span>)</span> {
            break<span class="comment">;</span>
        }
        tmp.substring<span class="list">(<span class="number">0</span>, j)</span><span class="comment">;</span>
        tmp = tmp.substring<span class="list">(<span class="keyword">j</span> + <span class="number">1</span>)</span><span class="comment">;</span>
    }
    tmp = old<span class="comment">;</span>
}
System.out.println<span class="list">(<span class="keyword">System</span>.currentTimeMillis<span class="list">()</span> - l1)</span><span class="comment">;</span></span></span></span>
</code></pre><p>结果如下：</p>
<ul>
<li>jdk1.6中 <code>1073 295</code>    </li>
<li>jdk1.8中 <code>606 7177</code></li>
</ul>
<p>对比1073与606，在1.8中由于取消了offset和count2个字段，所以spilt的性能有了较大的提升。<br>对比295与7177，在1.6中，由于substring方法不会产生新字符串，所以速度更快。在1.8中每次spilt都会产生新的字符串，造成了性能瓶颈。</p>
<h3 id="startWith替代">startWith替代</h3><p>我们看看下面一段代码：</p>
<pre><code><span class="keyword">String</span> ss = <span class="string">"abcdefgg"</span>;
<span class="built_in">int</span> i = <span class="number">10000000</span>;
<span class="keyword">long</span> l = System.currentTimeMillis();
<span class="keyword">for</span> (<span class="built_in">int</span> i1 = i; i1 &gt; <span class="number">0</span>; i1--) {
    <span class="built_in">boolean</span> a = ss.startsWith(<span class="string">"abc"</span>);
}
System.out.<span class="built_in">println</span>(System.currentTimeMillis() - l);
<span class="keyword">long</span> l1 = System.currentTimeMillis();
<span class="keyword">for</span> (<span class="built_in">int</span> i1 = i; i1 &gt; <span class="number">0</span>; i1--) {
    <span class="built_in">boolean</span> c = ss.charAt(<span class="number">0</span>)==<span class="string">'a'</span>&amp;&amp;ss.charAt(<span class="number">1</span>)==<span class="string">'b'</span>&amp;&amp;ss.charAt(<span class="number">2</span>)==<span class="string">'c'</span>;
}
System.out.<span class="built_in">println</span>(System.currentTimeMillis() - l1);
</code></pre><p>打印结果如下：</p>
<ul>
<li>在jdk1.6中 <code>109 26</code></li>
<li>在jdk1.8中 <code>22 21</code></li>
</ul>
<p>为什么会出现这样的结果呢，我们分析代码，发现</p>
<pre><code><span class="comment">//1.6</span>
<span class="function"><span class="keyword">public</span> boolean <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>{
    <span class="keyword">char</span> ta[] = <span class="keyword">value</span>;
    <span class="keyword">int</span> to = offset + toffset;
    <span class="keyword">char</span> pa[] = prefix.<span class="keyword">value</span>;
    <span class="keyword">int</span> po = prefix.offset;
    <span class="keyword">int</span> pc = prefix.count;
    <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span>
    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; count - pc)) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) {
        <span class="keyword">if</span> (ta[to++] != pa[po++]) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="comment">//1.8</span>
<span class="function"><span class="keyword">public</span> boolean <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>{
    <span class="keyword">char</span> ta[] = <span class="keyword">value</span>;
    <span class="keyword">int</span> to = toffset;
    <span class="keyword">char</span> pa[] = prefix.<span class="keyword">value</span>;
    <span class="keyword">int</span> po = <span class="number">0</span>;
    <span class="keyword">int</span> pc = prefix.<span class="keyword">value</span>.length;
    <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span>
    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; <span class="keyword">value</span>.length - pc)) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) {
        <span class="keyword">if</span> (ta[to++] != pa[po++]) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>在1.6中第四行，<code>int to = offset + toffset;</code>进行了整形相加操作，这里影响了方法的执行时间。1.7及以后去掉了offset和count，性能有了极大的提升。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://blog.csdn.net/chaofanwei/article/details/19486919" target="_blank" rel="external">深入理解java虚拟机（三）：String.intern()-字符串常量池</a></li>
<li><a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" title="深入解析String#intern" target="_blank" rel="external">http://tech.meituan.com/in_depth_understanding_string_intern.html</a></li>
<li>《java程序性能优化-让你的程序更快更稳定》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/26/java-string/" data-id="ci9b8x74q0039p8gorgqlwzdh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/j2se/">j2se</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/string/">string</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-collection-total" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/25/collection-total/" class="article-date">
  <time datetime="2015-04-25T08:37:30.000Z" itemprop="datePublished">4月 25 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/25/collection-total/">java集合小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要从整体架构，功能特性，和其他方面介绍集合。</p>
<h2 id="一-整体架构">一.整体架构</h2><p>上图：<br><img src="/img/collections.png" alt="集合架构"><br>我们可以看到集合主要分为set，list和queue这三类，似乎还有一个Stack。它在哪里呢？<br>我们看JDK代码：<code>public class Stack&lt;E&gt; extends Vector&lt;E&gt;</code>，原来它继承了Vector。</p>
<p>看上面这个图，我们是不是有点疑问，为什么Linkedlist实现了List又实现了Queue。这是因为List可以模拟Queue的行为，所以也可以将他看成是Queue对象，只需要去掉List的随机访问需求即可，从而实现更高效的并发。</p>
<p>了解了Collection后，我们发现JDK中还有个Collections，它是什么鬼东西？查看源码，我们发现它是包含了对Collection的基本静态方法，例如排序，创建，复制等。同理，Arrays是对数组的操作，Executors是对Executor的操作。有没有一种感觉写jdk的人喜欢用名称加s来代表一个utils。</p>
<h3 id="SET">SET</h3><p>一个不包括重复元素（包括可变对象）的Collection，是一种无序的集合。Set不包含满 a.equals(b) 的元素对a和b，并且最多有一个null。实现Set的接口有：EnumSet、HashSet、TreeSet等。下图是Set的JDK源码UML图。<br><img src="/img/collection-set.png" alt="set"></p>
<h3 id="List">List</h3><p>一个有序的Collection（也称序列），元素可以重复。确切的讲，列表通常允许满足 e1.equals(e2) 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。实现List的有：ArrayList、LinkedList、Vector、Stack等。下图是List的JDK源码UML图。<br><img src="/img/collection-list.png" alt="list"></p>
<h3 id="Queue">Queue</h3><p>一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。另一种是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。虽然接口并未定义阻塞方法，但是实现类扩展了此接口。下图是Queue的JDK源码UML图。<br><img src="/img/collection-queue.png" alt="queue"></p>
<h2 id="二，功能特性">二，功能特性</h2><p>以下比较基于ArrayList，linkedList，Vector，Stack,HashSet,TreeSet,HashMap,TreeMap</p>
<h3 id="1，添加元素">1，添加元素</h3><p>在添加元素上，ArrayList，Vector的性能相对较差，原因是ArrayList在容量不够时需要扩充。</p>
<h3 id="2，查找元素">2，查找元素</h3><p>在查找元素上，ArrayList，linkedList，Vector，Stack的性能略差一点点，这是由于他们在查找时需要遍历整个集合。而Set，Map类型的都是通过hash后再在链表上查找，因此速度比较快。</p>
<h3 id="3，删除元素">3，删除元素</h3><p>在删除元素上，除了TreeMap和TreeSet外，其他集合类型的性能基本无差异，TreeSet基于TreeMap实现，TreeMap之所以性能相对较差的原因是它在删除时需要排序。<br>List适用于允许重复元素的单个对象集合场景，Set适用于不允许重复元素的单个对象集合场景，Map适合key-value结构的集合场景。</p>
<h2 id="三，并发结构">三，并发结构</h2><h3 id="1，ConcurrentHashMap">1，ConcurrentHashMap</h3><p>线程安全的haspmap，默认采用16个Segment存储对象。每个Segment一把锁，可允许16个线程同时并发的操作集合对象。</p>
<h3 id="2，CopyOnWriteArrayList">2，CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList是一个线程安全的，并且在读操作时无需加锁的ArrayList。</p>
<h3 id="3，ArrayBlockingQueue">3，ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个基于数组，先进先出的，线程安全的集合类，其特色为指定时间的阻塞读写，并且容量是可限制的。</p>
<blockquote>
<p>offer(E,long,TimeUnit) 插入元素到数组的尾部，如果数组已满，则等待。poll(E,long,TimeUnit)获取数组中的第一个元素，如果数组中没有元素，则等待。</p>
</blockquote>
<h3 id="4,LinkedBlockingQueue">4,LinkedBlockingQueue</h3><p>LinkedBlockingQueue采用链表的方式存储对象。</p>
<blockquote>
<p>对于读操作take和poll，采用一把锁，对于写操作put和poll，采用另一把锁。因此在高并发读写操作多的情况下，性能好于ArrayBlockingQueue。但在遍历和删除元素时，需要2把锁同时锁住。</p>
</blockquote>
<h3 id="5,IndentityHashMap">5,IndentityHashMap</h3><p>简单说IdentityHashMap与常用的HashMap的区别是：前者比较key时是“引用相等”而后者是“对象相等”，即对于k1和k2，当k1==k2时，IdentityHashMap认为两个key相等，而HashMap只有在k1.equals(k2) == true 时才会认为两个key相等。</p>
<h3 id="6,ConCurrentSkipListMap">6,ConCurrentSkipListMap</h3><p>SkipList是红黑树的一种简化替代方案，是个流行的有序集合算法。</p>
<h2 id="四，其他特性">四，其他特性</h2><h3 id="算法">算法</h3><ol>
<li>Colletions.sort(list) 与 Arrays.sort(T[]) </li>
</ol>
<p>Colletions.sort()实际会将list转为数组，然后调用Arrays.sort()，排完了再转回List。<br>PS. JDK8里，List有自己的sort()方法了，像ArrayList就直接用自己内部的数组来排，而LinkedList, CopyOnWriteArrayList还是要复制出一份数组。<br>而Arrays.sort()，对原始类型(int[],double[],char[],byte[])，JDK6里用的是快速排序，对于对象类型(Object[])，JDK6则使用归并排序。为什么要用不同的算法呢？</p>
<ol>
<li>JDK7的进步</li>
</ol>
<p>到了JDK7，快速排序升级为双基准快排(双基准快排 vs 三路快排)；归并排序升级为归并排序的改进版TimSort，一个JDK的自我进化。</p>
<ol>
<li>JDK8的进步</li>
</ol>
<p>再到了JDK8， 对大集合增加了Arrays.parallelSort()函数，使用fork-Join框架，充分利用多核，对大的集合进行切分然后再归并排序，而在小的连续片段里，依然使用TimSort与DualPivotQuickSort。</p>
<h3 id="五，参考资料">五，参考资料</h3><ol>
<li>《分布式JAVA应用 基础与实践》—-林昊</li>
<li><a href="http://calvin1978.blogcn.com/articles/jdk.html" target="_blank" rel="external">JDK78数则</a></li>
<li><a href="http://www.bysocket.com/?p=162" target="_blank" rel="external">Java 容器 &amp; 泛型（1）：认识容器</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/25/collection-total/" data-id="ci9b8x75p004hp8gozwbneabz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/collection/">collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/j2se/">j2se</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/25/mysql-index/" class="article-date">
  <time datetime="2015-04-25T08:26:28.000Z" itemprop="datePublished">4月 25 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/25/mysql-index/">mysql索引总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>索引是什么？索引是存储引擎用于快速找到记录的一种数据结构。</p>
<h2 id="索引分类">索引分类</h2><h3 id="B-Tree索引">B-Tree索引</h3><p>MyISAM使用前缀压缩技术使得索引更小。InnoDB按照原数据存储索引。<br>MyISAM索引通过数据的物理位置引用被索引的行。InnoDB根据主键引用被索引的行。<br>可以使用B-Tree索引的查询类型：</p>
<ul>
<li>全值匹配：和索引中的所有列进行匹配</li>
<li>匹配最左前缀：匹配第一个索引</li>
<li>匹配列前缀：匹配某一列的值的开头部分，只使用第一个索引</li>
<li>匹配范围值：匹配某个范围，只使用第一个索引</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
<li>排序操作：索引的有序性</li>
</ul>
<h3 id="哈希索引">哈希索引</h3><p>哈希索引基于哈希表实现，只有精确匹配所有列的查询才有效。对于每一行数据，存储引擎会对所有的索引列计算一个hash值。<br>哈希索引的限制：</p>
<ul>
<li>哈希索引只能包含哈希值和行指针，不能使用索引的值避免行读取。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li>
<li>哈希索引只支持等值查找。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突。</li>
</ul>
<h3 id="空间数据索引">空间数据索引</h3><p>地理数据索引。（略）</p>
<h3 id="全文索引">全文索引</h3><p>全文索引查找文本中的关键词，一般采用倒排索引。</p>
<h3 id="其他">其他</h3><h2 id="索引的优点">索引的优点</h2><p>索引可以让服务器快速的定位到指定的位置。</p>
<ul>
<li>索引大大减少了服务器需要扫描的数量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机IO变为顺序IO。</li>
</ul>
<p>参考:Relational Database Index Design and the Optimizers.</p>
<p>索引是最好的解决方案吗？<br>对于非常小的表，大部分情况下简单的全表扫描更高效。<br>对于中大型的表，索引就非常有效。<br>对于特大型的表，建立和使用索引的代价随之增长。可以采用分区技术等。</p>
<h2 id="索引策略">索引策略</h2><h3 id="独立的列">独立的列</h3><p>索引列不能是表达式的一部分，也不能使函数的参数。</p>
<h3 id="前缀索引和索引选择性">前缀索引和索引选择性</h3><p>有时候需要索引很长的字符列，会让索引变得很大，这是我们可以使用哈希索引。我们是否还有更好的方法？</p>
<p>通常可以索引开始的部分字符，这样可以节省索引空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<h3 id="多列索引">多列索引</h3><p>很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p>在多个列上建立独立的单列索引大部分情况下并不能提高MySql的查询性能。MySql5.0以上引入了一种“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>
<h3 id="选择合适的索引列顺序">选择合适的索引列顺序</h3><p>经验法则：将选择性最高的列放在索引最前列。</p>
<h3 id="聚簇索引">聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引索引实际上在同一个结构中保存了B-Tree索引和物理行。<br>当表有聚簇索引时，实际上它的数据行保存在索引的叶子节点中。所以，一个表中只能有一个聚簇索引。</p>
<p>聚簇索引的优点：</p>
<ul>
<li>把相关数据保存在一起</li>
<li>数据访问更快，提高了IO的性能</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入速度依赖于插入顺序。</li>
<li>更新索引的代价很高。</li>
<li>插入新行，更新主键或者移动行的时候，面临“页分裂”的问题。</li>
<li>可能导致全表扫描变慢，尤其是行稀疏，也分裂导致数据不连续</li>
<li>二级索引（非聚簇索引）可能比想象的大，因为包含了主键列。</li>
</ul>
<h3 id="覆盖索引">覆盖索引</h3><p>如果索引的叶子节点已经包含了需要查询的字段，那么还有什么必要再回表查询？如果一个索引包含所有需要查询的字段的值，我们就称为“覆盖索引”。</p>
<p>适应场景：</p>
<ul>
<li>索引条目通常远小于数据行的大小。</li>
<li>对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要小的多。</li>
<li>可内存缓存索引，避免系统调用</li>
</ul>
<h3 id="使用索引进行排序">使用索引进行排序</h3><p>当索引的列序列和order by子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySql才能够使用索引来对结果进行排序。如果查询关联多个表时，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引进行排序。ORDER BY 子句和查找型查询的限制是一样的：需要全部满足索引的最左前缀的要求；否则，MySql都需要执行排序操纵，而无法利用索引进行排序。</p>
<p>有一种情况下ORDER BY子句可以不满足索引的最左前缀要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>
<h3 id="索引和锁">索引和锁</h3><p>索引可以让查询锁定更少的行。如果你的查询不需要访问那些不需要的行，那么就会锁定更少的行。</p>
<h2 id="设计原则">设计原则</h2><h3 id="选择性特别低，并且经常用到的的作为索引前列">选择性特别低，并且经常用到的的作为索引前列</h3><p>例如性别只有2种选择，但是我们经常会用到。如果没有用到性别查询，我们也可以使用 sex in（‘m’，‘f’）来让mysql选择该索引。</p>
<p>有一点需要注意的是，使用in的方式覆盖不在where条件中查询的列，不能过度使用。因为每增加一个in条件，优化器都需要以指数的形式增加，a<em>b</em>c。</p>
<h3 id="对于经常性范围查询，应放到索引后列">对于经常性范围查询，应放到索引后列</h3><p>对于范围查询，MySql无法再使用范围列后面的其他索引了，但是对于多个“等值条件查询”则没有这个限制。<br>例如年龄查询，可能是查询某个范围的，我们就要放到后面。</p>
<h3 id="避免多个范围查询">避免多个范围查询</h3><p>使用in来代替多范围查询</p>
<h3 id="优化排序">优化排序</h3><p>对于选择性非常低的列，可以添加一些特殊的索引进行排序。<br>例如sex进行排序时，可以使用(sex,rating)索引进行排序。<br>select <cols> from table where sex=’M’ order by rating ;</cols></p>
<p>PS:本文总结来自《mysql高性能》一书</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/25/mysql-index/" data-id="ci9b8x72y001fp8goueezvytc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/index/">index</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tomcat-artic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/06/tomcat-artic/" class="article-date">
  <time datetime="2015-04-06T04:35:21.000Z" itemprop="datePublished">4月 6 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/06/tomcat-artic/">tomcat架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tomcat虽然比较复杂，但是结构优良，下面让我们看看其良好的架构设计。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/06/tomcat-artic/" data-id="ci9b8x724000gp8goq9jbhobx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tomcat/">tomcat</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nosql-distilled" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/05/nosql-distilled/" class="article-date">
  <time datetime="2015-04-05T07:43:14.000Z" itemprop="datePublished">4月 5 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/nosql-distilled/">Nosql精粹读书笔记（一）——聚合数据模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="聚合数据模型">聚合数据模型</h2><p><strong>数据模型是认知和操作数据时所用的模型。</strong>对于使用数据库的人来说， 数据模型描述了我们如何同数据库中的数据打交道。 它与存储模型不同， 后者描述了数据库内部存储及操作数据的机制。 </p>
<p>大家日常所说的“ 数据模型” 一词， 一般指应用程序的特定数据所具备的模型。 开发者可能会指着一张数据库的“ 实体 - 关系图 ”（ entity-relationship diagram）， 把这个包含客户、 订单、 产品等信息的东西叫做他们的数据模型。然而本书的“ 数据模型” 通常表示数据库组织数据的方式， 它的正式名称是“ 元模型”（ metamodel）。</p>
<p>NoSQL 技术与传统的关系型数据库相比， 一个最明显的转变就是抛弃了关系模型。 每种 NoSQL 解决方案的模型都不同， 本书把 NoSQL 生态系统中广泛使用的模型分为四类 ：“ 键值”、“ 文档”、“ 列族” 和“ 图”。 前三类数据模型有一个共同特征， 我们称其为“ 面向聚合”（ aggregate orientation）。</p>
<h3 id="聚合">聚合</h3><p><strong>关系模型把待存储的信息分隔成元组（ 行）。</strong> 元组是种受限的数据结构 ： 它只能包含一系列的值， 因此不能在元组中嵌套另一个元组， 也不能包含由值或元组所组成的列表。 这种简单的数据结构支撑着关系模型 ： 所有操作都必须以元组为目标， 而且其返回值也必须是元组。</p>
<p>面向聚合所用的方式与之不同， 我们通常操作数据时所用的单元， 其结构都比元组集合复杂得多。 如果能够以这种复杂的结构来存放列表或嵌套其他记录结构就好了。大家在后面的章节中将会看到，“键值数据库”、“ 文档数据库”、“ 列族数据库” 都使用这种更为复杂的记录。 然而， 没有公认的术语来称呼这种复杂的记录， 在本书中， 把它叫做“聚合”（ aggregate）。</p>
<p>聚合是“ 领域驱动设计”［ Evans］ 中的术语。 <strong>在领域驱动设计中， 我们想把一组相互关联的对象视为一个整体单元来操作， 而这个单元就叫聚合。</strong> 在涉及数据操作与一致性管理时， 更是如此。 一般情况下， 我们通过原子操作（ atomic operation） 更新聚合的值， 并且在与数据存储通信时， 也以聚合为单位。 这个定义也非常符合“ 键值数据库”、“ 文档数据库” 和“ 列族数据库” 的工作方式。 因为用聚合为单位来复制和分片显得比较自然， 所以在集群中操作数据库时， 还是使用聚合比较简单一些。 此外，由于程序员经常通过聚合结构来操作数据， 故而采用聚合也能让其工作更为轻松。</p>
<h4 id="关系模型与聚合模型示例">关系模型与聚合模型示例</h4><p><img src="/img/QQ图片20150405155439.png" alt=""><br><img src="/img/QQ图片20150405155535.png" alt=""><br>现在我们再来看看， 如果用面向聚合的思路来做， 那么数据模型会是什么样子<br><img src="/img/QQ图片20150405155628.png" alt=""><br>这次也要用一些范例数据， 我们使用 JSON 格式来表示， 因为它是 NoSQL 领域中常用的数据格式。<br><img src="/img/QQ图片20150405155833.png" alt=""></p>
<h4 id="面向聚合的影响">面向聚合的影响</h4><p>关系型数据库的数据模型中， 没有“ 聚合” 这一概念， 因此我们称之为“ 聚合无知”（ aggregate-ignorant）。 NoSQL 领域中的“ 图数据库” 也是聚合无知的。 这一特征并不是坏事。 聚合的边界一般都很难正确划分出来， 当不同场景要使用同一份数据时，更是如此。 </p>
<p>选用面向聚合模型的决定性因素， 就在于它非常适合在集群上运行。 大家应该还记得， 这正是 NoSQL 崛起的杀手锏。在集群上运行时， 我们需要把采集数据时所需的节点数降至最小。如果在数据库中明确包含聚合结构， 那么它就可以根据这一重要信息， 知道哪些数据需要一起操作了， 而且这些数据应该放在同一个节点中。</p>
<p>聚合对于事务处理有一个重要影响。 通常情况下， 面向聚合的数据库确实不支持跨越多个聚合的ACID 事务。 取而代之的是， 它每次只能在一个聚合结构上执行原子操作。 也就是说，如果我们想以原子方式操作多个聚合， 那么就必须自己组织应用程序的代码。</p>
<h3 id="键值数据模型与文档数据模型">键值数据模型与文档数据模型</h3><p>键值数据库的聚合不透明 ， 只包含一些没有太多意义的大块信息 ； 与此相反， 在文档数据库的聚合中， 可以看到其结构。 不透明的优势在于， 聚合中可以存储任意数据。文档数据库则要限制其中存放的内容， 它定义了其允许的结构与数据类型， 而这样做的好处是， 能够更加灵活地访问数据。</p>
<p>在键值数据库中， 要访问聚合内容， 只能通过键来查找。 而使用文档数据库时，则可以用聚合中的字段查询。 我们可以只获取一部分聚合， 而不用获取全部内容， 此外， 数据库还可以按照聚合内容创建索引 。</p>
<h3 id="列族存储">列族存储</h3><p>理解列族模型的最好方式也许就是将其视为两级聚合结构（ two-level aggregate<br>structure）。 与“ 键值存储” 相同，第一个键通常代表行标识符， 可以用它来获取想要的聚合。 列族结构与“ 键值存储” 的区别在于， 其“ 行聚合”（ row aggregate） 本身又是一个映射， 其中包含一些更为详细的值。 这些“ 二级值”（ second-level value）就叫做“ 列”。 与整体访问某行数据一样， 我们也可以操作特定的列。</p>
<p>列族数据库将列组织为列族。 每一列都必须是某个列族的一部分， 而且访问数据的单元也得是列。 这样设计的前提是， 某个列族中的数据经常需要一起访问。<br><img src="/img/QQ图片20150405161008.png" alt=""><br>于是， 我们也得出了两种数据组织方式。</p>
<ul>
<li>面向行（ row-oriented）： 每一行都是一个聚合（ 例如 ID 为 1234 的顾客就是一个聚合）， 该聚合内部存有一些包含有用数据块（ 客户信息、 订单记录） 的列族。</li>
<li>面向列（ column-oriented）： 每个列族都定义了一种记录类型（ 例如客户信息），其中每行都表示一条记录 。 你可以将数据库中的大“ 行” 理解为列族中每一个短行记录的串接。</li>
</ul>
<h3 id="总结">总结</h3><p>键值数据模型将聚合看作不透明的整体，这意味着只能根据键来查出整个聚合， 而不能仅仅查询或获取其中的一部分。</p>
<p>文档模型的聚合对数据库透明， 于是就可以只查询并获取其中一部分数据了， 不过， 由于文档没有模式， 因此在想优化存储并获取聚合中的部分内容时， 数据库不太好调整文档结构。</p>
<p>列族模型把聚合分为列族， 让数据库将其视为行聚合内的一个数据单元。 此类聚合的结构有某种限制， 但是数据库可利用此种结构的优点来提高其易访问性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/05/nosql-distilled/" data-id="ci9b8x72t001bp8gogyiq1lwj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mongodb-biji" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/05/mongodb-biji/" class="article-date">
  <time datetime="2015-04-05T04:06:03.000Z" itemprop="datePublished">4月 5 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/mongodb-biji/">MongoDB权威指南笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="特点">特点</h2><p>MongoDB是它是一个面向集合的,模式自由的文档型数据库。那么什么是文档性数据库呢？它与其他的数据库的差别在哪里？</p>
<ol>
<li><p>面向集合的存储（ Collenction-Orented）：适合存储对象及JSON形式的数据。</p>
<p> 意思是数据被分组存储在数据集中， 被称为一个集合（ Collenction)。每个集合在数据库中都有一个唯一的标识名 ，并且可以包含无限数目的文档 。集合的概念类似关系型数据库（ RDBMS）里的表（ table）， 不同的是它不需要定义任何模式（ schema)。</p>
</li>
<li><p>模式自由（（ schema-free)</p>
<p> 意味着对于存储在 MongoDB 数据库中的文件，我们不需要知道它的任何结构定义。提了这么多次”无模式”或”模式自由 “，它到是个什么概念呢？例如，下面两个记录可以存在于同一个集合里面：<br> {“welcome” : “Beijing”}<br> {“age” : 25}</p>
</li>
<li><p>文档型</p>
<p> 意思是我们存储的数据是键-值对的集合,键是字符串,值可以是数据类型集合里的任意类型,包括数组和文档 . 我们把这个数据格式称作 “ BSON ” 即 “ Binary Serialized dOcument Notation.”</p>
</li>
</ol>
<h2 id="适用场景">适用场景</h2><p><strong>网站数据</strong>： MongoDB 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性</p>
<p><strong>缓存</strong>：由于性能很高， MongoDB 也适合作为信息基础设施的缓存层。在系统重启之后，由 MongoDB 搭建的持久化缓存层可以避免下层的数据源过载</p>
<p><strong>大尺寸，低价值的数据</strong>：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储</p>
<p><strong>高伸缩性的场景</strong>： MongoDB 非常适合由数十或数百台服务器组成的数据库。 MongoDB的路线图中已经包含对 MapReduce 引擎的内置支持</p>
<p><strong>用于对象及 JSON 数据的存储</strong>： MongoDB 的 BSON 数据格式非常适合文档化格式的存储及查询</p>
<h2 id="数据逻辑结构">数据逻辑结构</h2><p> MongoDB 的文档（ document）， 相当于关系数据库中的一行记录。<br> 多个文档组成一个集合（ collection）， 相当于关系数据库的表。<br> 多个集合（ collection）， 逻辑上组织在一起，就是数据库（ database）。<br> 一个 MongoDB 实例支持多个数据库（ database）。<br><img src="/img/mongodb_luojijiegou.png" alt=""><br>文档(document)、集合(collection)、数据库(database)的层次结构如下图:<br><img src="/img/mongodb_chengci.png" alt=""></p>
<h2 id="性能篇">性能篇</h2><p>MongoDB 提供了多样性的索引支持，索引信息被保存在 system.indexes 中，且默认总是为_id<br>创建索引 ，它的索引使用基本和 MySQL 等关系型数据库一样。</p>
<h3 id="基础索引">基础索引</h3><pre><code>在字段 <span class="tag">age</span> 上创建索引， 1(升序);<span class="tag">-1</span>(降序)
<span class="tag">db</span><span class="class">.t3</span><span class="class">.ensureIndex</span>(<span class="rules">{<span class="rule"><span class="attribute">age</span>:<span class="value"><span class="number">1</span>})</span></span></span>
</code></pre><h3 id="文档索引">文档索引</h3><pre><code>db.factories.insert( { name: <span class="string">"wwl"</span>, addr: { city: <span class="string">"Beijing"</span>, <span class="keyword">state</span>: <span class="string">"BJ"</span> } } );
db.factories.ensureIndex( { addr : <span class="number">1</span> } );
//下面这个查询将会用到我们刚刚建立的索引
db.factories.find( { addr: { city: <span class="string">"Beijing"</span>, <span class="keyword">state</span>: <span class="string">"BJ"</span> } } );
//但是下面这个查询将不会用到索引，因为查询的顺序跟索引建立的顺序不一样
db.factories.find( { addr: { <span class="keyword">state</span>: <span class="string">"BJ"</span> , city: <span class="string">"Beijing"</span>} } );
</code></pre><h3 id="组合索引">组合索引</h3><pre><code><span class="keyword">db</span>.factories.ensureIndex( { <span class="string">"addr.city"</span> : 1, <span class="string">"addr.state"</span> : 1 } );
<span class="comment">// 下面的查询都用到了这个索引</span>
<span class="keyword">db</span>.factories.find( { <span class="string">"addr.city"</span> : <span class="string">"Beijing"</span>, <span class="string">"addr.state"</span> : <span class="string">"BJ"</span> } );
<span class="keyword">db</span>.factories.find( { <span class="string">"addr.city"</span> : <span class="string">"Beijing"</span> } );
<span class="keyword">db</span>.factories.find().<span class="keyword">sort</span>( { <span class="string">"addr.city"</span> : 1, <span class="string">"addr.state"</span> : 1 } );
<span class="keyword">db</span>.factories.find().<span class="keyword">sort</span>( { <span class="string">"addr.city"</span> : 1 } )
</code></pre><h2 id="架构篇">架构篇</h2><p>MongoDB 支持在多个机器中通过异步复制达到故障转移和实现冗余。多机器中同一时刻只有一台是用于写操作。正是由于这个情况，为 MongoDB 提供了数据一致性的保障。担当Primary 角色的机器能把读操作分发给 slave。</p>
<h3 id="复制集">复制集</h3><p>MongoDB 高可用可用分两种:</p>
<ul>
<li><p>Master-Slave 主从复制：</p>
<p>  只需要在某一个服务启动时加上–master 参数，而另一个服务加上–slave 与–source 参数，即可实现同步。 MongoDB 的最新版本已不再推荐此方案。</p>
</li>
<li><p>Replica Sets 复制集：</p>
<p>  MongoDB 在 1.6 版本对开发了新功能 replica set，这比之前的 replication 功能要强大一些，增加了故障自动切换和自动修复成员节点，各个 DB 之间数据完全一致，大大降低了维护成功。 auto shard 已经明确说明不支持 replication paris，建议使用 replica set， replica set故障切换完全自动。<br><img src="/img/mongodb_replica.png" alt=""></p>
</li>
</ul>
<h3 id="Sharding_分片">Sharding 分片</h3><p>这是一种将海量的数据水平扩展的数据库集群系统，数据分表存储在 sharding 的各个节点上，使用者通过简单的配置就可以很方便地构建一个分布式 MongoDB 集群。</p>
<p>要构建一个 MongoDB Sharding Cluster，需要三种角色：</p>
<ul>
<li><p>Shard Server</p>
<p>  即存储实际数据的分片，每个 Shard 可以是一个 mongod 实例，也可以是一组 mongod 实例构成的 Replica Set。为了实现每个 Shard 内部的 auto-failover， MongoDB 官方建议每个 Shard为一组 Replica Set。</p>
</li>
<li><p>Config Server</p>
<p>  为了将一个特定的 collection 存储在多个 shard 中，需要为该 collection 指定一个shard key，例如{age: 1} ，shard key 可以决定该条记录属于哪个 chunk。 Config Servers 就是用来存储：所有 shard 节点的配置信息、每个 chunk 的 shard key 范围、 chunk 在各 shard 的分布情况、该集群中所有 DB 和 collection 的 sharding 配置信息。</p>
</li>
<li><p>Route Process</p>
<p>  这是一个前端路由，客户端由此接入，然后询问 Config Servers 需要到哪个 Shard 上查询或保存记录，再连接相应的 Shard 进行操作，最后将结果返回给客户端。客户端只需要将原本发给 mongod 的查询或更新请求原封不动地发给 Routing Process，而不必关心所操作的记录存储在哪个 Shard 上。<br><img src="/img/mongodb_shard.png" alt=""></p>
</li>
</ul>
<h3 id="Replica_Sets_+_Sharding">Replica Sets + Sharding</h3><p>MongoDB Auto-Sharding 解决了海量存储和动态扩容的问题，但离实际生产环境所需的高可<br>靠、高可用还有些距离，所以有了 ” Replica Sets + Sharding”的解决方案:</p>
<ul>
<li><p>Shard:</p>
<p>  使用 Replica Sets，确保每个数据节点都具有备份、自动容错转移、自动恢复能力。</p>
</li>
<li><p>Config:</p>
<p>  使用 3 个配置服务器，确保元数据完整性</p>
</li>
<li><p>Route:</p>
<p>  使用 3 个路由进程，实现负载平衡，提高客户端接入性能</p>
</li>
</ul>
<p><img src="/img/mongodb_replica_shard.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/05/mongodb-biji/" data-id="ci9b8x731001lp8go0xtg3jcv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nosql/">nosql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mondrian-source-code-9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/04/mondrian-source-code-9/" class="article-date">
  <time datetime="2015-04-04T10:41:49.000Z" itemprop="datePublished">4月 4 2015</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/04/mondrian-source-code-9/">mondrian 源码解读（九）-聚集层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>包mondrian.rolap.agg，管理聚合缓存，这些缓存中包含着各单元格值。<br>RolapStar中含有aggregation(聚合)，一个aggregation是针对一组columns的，该聚合可以包含多个segment，同一个aggregation中的每个segment都将覆盖到相同的列集合；每个segment表达了一组cell值，这些cell自然是由具体的列值和一个必备度量值(如下面的unit sales)来限定，如：<code>(Unit sales, Gender = &#39;F&#39;, State  in {&#39;CA&#39;,&#39;OR&#39;}, Marital Status = anything)</code>，由于其中的列值可能会取多个，因此最终表达的cell值也可能是多个。RolapStar中有一个aggregations，是一个map对象，通过request的constrainedColumnsBitKey来索引一个aggregation。</p>
<h2 id="聚合装载过程">聚合装载过程</h2><p>实际中无论是底层的单元值还是聚合后的单元值都是放在聚合对象aggregation中的。以aggregation.load(colums,measures,predicates,pinnedSegments)为入口：</p>
<p>参数中的除了measure不一样外，其限定的列(colums)及列值（prediactes）都是一致的。因此转换成对对若干segment[]的求值： Segment.load(segment[]，….)，在该方法内部：</p>
<ul>
<li>首先根据segments中的信息生成sql查询语句，有两个不同的生成类：AggQuerySpec和SegmentArrayQuerySpec，前者用于找到聚合表情况下的sql语句生成，后者用于基于原始表的sql语句生成。具体可以参见它们的generateSqlQuery()方法，这里注意对以distinct count有不同的生成方法。Sql生成的核心类是sqlQuery，类似于交换系统中的QuerySqlFactory类。注意：聚合操作如avg、sum等都最终还是利用sql语句实现的，并非mondiran自己实现这些聚合功能。</li>
<li>利用jdbc，执行sql语句，获取到jdbc 结果集。参见mondrian.rolap.RolapUtil.executeQuery()方法。</li>
<li>解析结果集，将结果集中的数据填充到rows[][]二维数值中，并且把各列的值也填充好。如图：<br>结果集每条记录的值如宁波市、G010….,前面两个是维度列值，后面几个是度量值。<br><img src="/img/mondrian_agg1.png" alt=""><br>各列的值(其中第0项值为：[宁波市])：<br><img src="/img/mondrian_agg2.png" alt=""></li>
<li>决定采用稀疏性(sparse)还是稠密性（dense）SegmentDataSet存储（如果是稠密的，就用数组存储，如果是稀疏的，则用Map存储）；并创建该空的DataSet对象。每个segment关联一个DataSet对象；但其稀疏性还是稠密性都是一致的。注意dataset中单元值的个数可能是1个或多个，是由各限定列的指定值个数乘积，若所有限定列都取单值，则显然最终决定一个唯一的单元。</li>
<li>将上述的rows中间集转换到SegmentDataSets集中。最后再分拣给每个segment，确保每个segment的setData(SegmentDataSet)被调用。</li>
</ul>
<h2 id="segment详解">segment详解</h2><p>我们看Segment里面都放了什么：</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">final</span> Column[] columns; <span class="comment">//约束列</span>
<span class="keyword">public</span> <span class="keyword">final</span> MeasureColumn measure;<span class="comment">//这个segment是针对哪个度量的。</span>
<span class="keyword">private</span> RolapModel model; <span class="comment">//对模型的引用</span>
<span class="keyword">public</span> <span class="keyword">final</span> StarColumnPredicate[] predicates; <span class="comment">//Segment存在哪些断言</span>
</code></pre><p>从这里我们可以看出，Segment就是对某个Cube的断面做的定义。那它的单元值是存在哪里呢？<br>就是我们在上面讲的到SegmentDataSet，由它来存储单元值。那么如何关联Segment与SegmentDataSet呢？这里我们有要讲到SegmentWithData。我们看他的定义：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">SegmentWithData</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Segment</span>{</span>
    <span class="keyword">final</span> <span class="type">SegmentAxis</span>[] axes;<span class="comment">//一组维度的约束</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SegmentDataset</span> data;<span class="comment">//数据存储</span>
...
    <span class="comment">//此方法判断SegmentWithData中是否存在以keys为维度的单元值</span>
    public <span class="type">Object</span> getCellValue(<span class="type">Object</span>[] keys) {
        assert keys.length == axes.length;
        int missed = <span class="number">0</span>;
        <span class="type">CellKey</span> cellKey = <span class="type">CellKey</span>.<span class="type">Generator</span>.newCellKey(axes.length);
        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; keys.length; i++) {
            <span class="type">Comparable</span> key = (<span class="type">Comparable</span>) keys[i];
            int offset = axes[i].getOffset(key);
            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) {
                <span class="keyword">if</span> (axes[i].wouldContain(key)) {
                    <span class="comment">// see whether this segment should contain this value</span>
                    missed++;
                    <span class="keyword">continue</span>;
                } <span class="keyword">else</span> {
                    <span class="comment">// this value should not appear in this segment; we</span>
                    <span class="comment">// should be looking in a different segment</span>
                    <span class="keyword">return</span> <span class="literal">null</span>;
                }
            }
            cellKey.setAxis(i, offset);
        }
        <span class="keyword">if</span> (isExcluded(keys)) {
            <span class="comment">// this value should not appear in this segment; we</span>
            <span class="comment">// should be looking in a different segment</span>
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        <span class="keyword">if</span> (missed &gt; <span class="number">0</span>) {
            <span class="comment">// the value should be in this segment, but isn't, because one</span>
            <span class="comment">// or more of its keys does have any values</span>
            <span class="keyword">return</span> <span class="type">FunUtil</span>.nullValue;
        } <span class="keyword">else</span> {
            <span class="comment">//cellkey是对一组维度的值得定义</span>
            <span class="type">Object</span> o = data.getObject(cellKey);
            <span class="keyword">if</span> (o == <span class="literal">null</span>) {
                o = <span class="type">FunUtil</span>.nullValue;
            }
            <span class="keyword">return</span> o;
        }
    }
}    
</code></pre><p>在这里，SegmentWithData包装了Segment与它单元值之间的关系，通过SegmentAxis来判断当前比较的值是否相同。</p>
<p>下图是有两个限定列的两个segment的描述(注:其中roadid列虽然指定了8个候选值，但由于使用了空行/列过滤，最后只剩下两个路线有值，故最后segment结果集的单元数也只有两个，对应于G010和G318的)：<br><img src="/img/mondrian_agg3.png" alt=""><br><img src="/img/mondrian_agg4.png" alt=""><br>其中第二个对应的dataset为：<br>[317.769, 120.604]<br>对应的透视界面为(参见其中的“观测里程”度量值，与上面的dataset一致)：<br><img src="/img/mondrian_agg5.png" alt=""></p>
<p>再譬如有三个限定列的segment描述，它们位于另一个aggreation对象中：(其中timeId列的any代表所以可能的时间值，共有2003~2005三个年，所以最终该segment共有3个cell值)<br><img src="/img/mondrian_agg6.png" alt=""><br>对应的dataset为：<br>[129.910, 129.909, 57.950]<br>对应的透视界面为(显然该aggreation还有另外一个segment，其中的roadId对应于G010—宁波梁辉)：<br><img src="/img/mondrian_agg7.png" alt=""></p>
<p>再譬如维度中有多个层次的情况时，一个维度会对应多个列：</p>
<pre><code><span class="type">Query</span> query = connection.parseQuery(
    <span class="string">"SELECT"</span> +
    <span class="string">" {[Time].[1997],"</span> +
    <span class="string">" [Time].[1997].Children} ON COLUMNS,"</span> +
    <span class="string">" {[Customer].[USA],"</span> +
    <span class="string">" [Customer].[USA].[OR],"</span> +
    <span class="string">" [Customer].[USA].[WA]} ON ROWS"</span> +
    <span class="string">"FROM [Sales]"</span>);
<span class="type">Result</span> <span class="literal">result</span> = connection.execute(query);
</code></pre><p>该语句执行后产生的segment分别为(除了第一个外，其他segment都会包含多个cell，因为它们的限定列中含有多值的情况)：</p>
<pre><code>Segment YN<span class="comment">#1    Year Nation Unit Sales</span>
                <span class="number">1997</span> USA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Nation=</span>USA

Segment YNS<span class="comment">#1    Year Nation State Unit Sales</span>
                <span class="number">1997</span> USA    OR    xxx
                <span class="number">1997</span> USA    WA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Nation=</span>USA, <span class="variable">State=</span>{OR, WA}

Segment YQN<span class="comment">#1    Year Quarter Nation Unit Sales</span>
                <span class="number">1997</span> Q1      USA    xxx
                <span class="number">1997</span> Q2      USA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Quarter=</span>any, <span class="variable">Nation=</span>USA

Segment YQNS<span class="comment">#1    Year Quarter Nation State Unit Sales</span>
                <span class="number">1997</span> Q1      USA    OR    xxx
                <span class="number">1997</span> Q1      USA    WA    xxx
                <span class="number">1997</span> Q2      USA    OR    xxx
                <span class="number">1997</span> Q2      USA    WA    xxx
Predicates: <span class="variable">Year=</span><span class="number">1997</span>, <span class="variable">Quarter=</span>any, <span class="variable">Nation=</span>USA, <span class="variable">State=</span>{OR, WA}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sqtds.github.io/2015/04/04/mondrian-source-code-9/" data-id="ci9b8x735001pp8gon92e57i8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/public/_posts/2015/page/2/">2</a><a class="extend next" rel="next" href="/public/_posts/2015/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能/">性能</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机原理/">计算机原理</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/antlr4/">antlr4</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aop/">aop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collection/">collection</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collections/">collections</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exception/">exception</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/groupby/">groupby</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/">idea</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/impala/">impala</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/index/">index</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/j2se/">j2se</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/">jdbc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk/">jdk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mondrian/">mondrian</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nosql/">nosql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oralce/">oralce</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plan/">plan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/string/">string</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tx/">tx</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列式/">列式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串替换/">字符串替换</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储/">存储</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能/">性能</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境变量/">环境变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机原理/">计算机原理</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 18px;">android</a><a href="/tags/antlr4/" style="font-size: 20px;">antlr4</a><a href="/tags/aop/" style="font-size: 10px;">aop</a><a href="/tags/collection/" style="font-size: 10px;">collection</a><a href="/tags/collections/" style="font-size: 10px;">collections</a><a href="/tags/exception/" style="font-size: 12px;">exception</a><a href="/tags/groupby/" style="font-size: 10px;">groupby</a><a href="/tags/hadoop/" style="font-size: 12px;">hadoop</a><a href="/tags/idea/" style="font-size: 10px;">idea</a><a href="/tags/impala/" style="font-size: 10px;">impala</a><a href="/tags/index/" style="font-size: 10px;">index</a><a href="/tags/j2se/" style="font-size: 14px;">j2se</a><a href="/tags/jdbc/" style="font-size: 10px;">jdbc</a><a href="/tags/jdk/" style="font-size: 10px;">jdk</a><a href="/tags/linux/" style="font-size: 14px;">linux</a><a href="/tags/mondrian/" style="font-size: 20px;">mondrian</a><a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a><a href="/tags/mysql/" style="font-size: 10px;">mysql</a><a href="/tags/nosql/" style="font-size: 12px;">nosql</a><a href="/tags/oralce/" style="font-size: 10px;">oralce</a><a href="/tags/plan/" style="font-size: 10px;">plan</a><a href="/tags/spring/" style="font-size: 16px;">spring</a><a href="/tags/string/" style="font-size: 10px;">string</a><a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a><a href="/tags/tx/" style="font-size: 14px;">tx</a><a href="/tags/列式/" style="font-size: 10px;">列式</a><a href="/tags/字符串替换/" style="font-size: 10px;">字符串替换</a><a href="/tags/存储/" style="font-size: 10px;">存储</a><a href="/tags/性能/" style="font-size: 10px;">性能</a><a href="/tags/源码/" style="font-size: 12px;">源码</a><a href="/tags/环境变量/" style="font-size: 10px;">环境变量</a><a href="/tags/计算机原理/" style="font-size: 10px;">计算机原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2015/05/">五月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2015/04/">四月 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/11/">十一月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/10/">十月 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/09/">九月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/08/">八月 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/06/">六月 2014</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/public/_posts/2014/05/">五月 2014</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/05/05/collections-uml/">集合UML图</a>
          </li>
        
          <li>
            <a href="/2015/04/29/linux-command/">(no title)</a>
          </li>
        
          <li>
            <a href="/2015/04/27/性能调优总结/">性能调优总结</a>
          </li>
        
          <li>
            <a href="/2015/04/26/java-string/">String字符串小结</a>
          </li>
        
          <li>
            <a href="/2015/04/25/collection-total/">java集合小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 sqtds<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>