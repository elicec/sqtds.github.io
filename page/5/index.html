<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>蜻蜓点水</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="蜻蜓点水">
<meta property="og:url" content="http://sqtds.github.io/page/5/index.html">
<meta property="og:site_name" content="蜻蜓点水">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蜻蜓点水">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="蜻蜓点水" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1bd1f966e3148e2b59e4b159067ad372";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="/img/photo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">sqtds</a></h1>
		</hgroup>

		
		<p class="header-subtitle">if you never try , you will lost forever.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/sqtds" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="/sqtds@163.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 16.67px;">android</a><a href="/tags/antlr4/" style="font-size: 18.33px;">antlr4</a><a href="/tags/hadoop/" style="font-size: 11.67px;">hadoop</a><a href="/tags/impala/" style="font-size: 10px;">impala</a><a href="/tags/java核心系列/" style="font-size: 20px;">java核心系列</a><a href="/tags/java源码阅读/" style="font-size: 13.33px;">java源码阅读</a><a href="/tags/linux/" style="font-size: 15px;">linux</a><a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a><a href="/tags/mondrian/" style="font-size: 18.33px;">mondrian</a><a href="/tags/nosql/" style="font-size: 11.67px;">nosql</a><a href="/tags/spring/" style="font-size: 15px;">spring</a><a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a><a href="/tags/分布式/" style="font-size: 10px;">分布式</a><a href="/tags/异常/" style="font-size: 10px;">异常</a><a href="/tags/性能/" style="font-size: 10px;">性能</a><a href="/tags/数据库/" style="font-size: 13.33px;">数据库</a><a href="/tags/计算机原理/" style="font-size: 10px;">计算机原理</a><a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是一名小小码农...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">sqtds</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">sqtds</h1>
			</hgroup>
			
			<p class="header-subtitle">if you never try , you will lost forever.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/sqtds" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="/sqtds@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2014/oracle-group-by" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/31/2014/oracle-group-by/" class="article-date">
  	<time datetime="2015-03-31T09:45:27.000Z" itemprop="datePublished">3月 31 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/31/2014/oracle-group-by/">Oracle rollup、cube、grouping sets</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Oracle的group by除了基本用法以外，还有3种扩展用法，分别是rollup、cube、grouping sets。</p>
<h2 id="1_rollup">1 rollup</h2><p>假设有一个表test，有A、B、C、D、E5列。<br>如果使用group by rollup(A,B,C)，首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。roll up的意思是“卷起”，这也可以帮助我们理解group by rollup就是对选择的列从右到左以一次少一列的方式进行grouping直到所有列都去掉后的grouping(也就是全表grouping)，对于n个参数的rollup，有n+1次的grouping。以下2个sql的结果集是一样的：</p>
<p><code>Select A,B,C,sum(E) from test group by rollup(A,B,C)</code><br>与</p>
<p><code>Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,null,null,sum(E) from test</code></p>
<h2 id="2_cube">2 cube</h2><p>cube的意思是立方，对cube的每个参数，都可以理解为取值为参与grouping和不参与grouping两个值的一个维度，然后所有维度取值组合的集合就是grouping的集合，对于n个参数的cube，有2^n次的grouping。如果使用group by cube(A,B,C),，则首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作，一共是2^3=8次grouping。同rollup一样，也可以用基本的group by加上结果集的union all写出一个与group by cube结果集相同的sql：<br><code>Select A,B,C,sum(E) from test group by cube(A,B,C);</code><br>与<br><code>Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,C,sum(E) from test group by A,C
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,B,C,sum(E) from test group by B,C
union all
Select null,B,null,sum(E) from test group by B
union all
Select null,null,C,sum(E) from test group by C
union all
Select null,null,null,sum(E) from test;</code></p>
<h2 id="3_grouping_sets">3 grouping sets</h2><p>grouping sets就是对参数中的每个参数做grouping，也就是有几个参数做几次grouping,例如使用<code>group by grouping sets(A,B,C)</code>，则对(A),(B),(C)进行group by，如果使用<code>group by grouping sets((A,B),C)</code>,则对(A,B),(C)进行group by。甚至<code>grouping by grouping set(A,A)</code>都是语法允许的，也就是对(A)进行2次group by,grouping sets的参数允许重复</p>
<h2 id="4_总结">4 总结</h2><ul>
<li>rollup        (N+1个分组方案)</li>
<li>cube         (2^N个分组方案)</li>
<li>grouping sets (自定义罗列出分组方案)</li>
</ul>
<hr>
<h2 id="5_注意点">5 注意点</h2><h3 id="5-1_机制不同">5.1 机制不同</h3><p>在rollup和cube的说明中分别给出了用基本group by加结果集union all给出了结果集相同的sql，但这只是为了理解的方便而给出的sql，并不说明rollup和cube与基本group by加结果集union all等价。实际上两者的内部机制是安全不一样的，前者除了写法简洁以外，运行时不需多次扫描表，效率远比后者高。</p>
<h3 id="5-2_集合可运算">5.2 集合可运算</h3><p>3种扩展用法的参数可以是源表中的某一个具体的列，也可以是若干列经过计算而形成的一个新列（比如说A+B，A||B），也可以是这两种列的一个集合（例如（A+B，C）），对于grouping set更是特殊，可以是空集合()，表示对全表进行group by。</p>
<h3 id="5-3_group_by_与_rollup,_cube组合使用">5.3 group by 与 rollup, cube组合使用</h3><p>Group by的基本用法以及这3种扩展用法可以组合使用，也就是说可以出现group by A,rollup(A,B)这样的用法，oracle将对出现在group by中的每种用法的grouping列集合做笛卡尔积然后对其中的每一个元素做group by。这话说起来挺绕口，举例说明吧，group by A, rollup(A,B)，基本用法的grouping集合是(A),rollup(A,B)的grouping集合是((A,B),(A),()),两个集合的笛卡尔积集合是((A,A,B),(A,A),(A))，所以会首先对(A,A,B)做group by，然后对(A,A)做group by，最后对(A)做group by。实际上对(A,A,B)做group by和对(A,B)做group by两者是完全等价的(group by A,A,B结果和group by A,B完全一样)，同理对(A,A)做group by和对(A)做group by也是等价的。简化后的结果就是首先对(A,B)做group by，然后对(A)做group by，最后再对(A)做group by。下面给出两个等价的sql以便理解：<br><code>Select A,B,sum(E) from test1 group by A, rollup(A,B);</code><br>与<br><code>Select A,B,sum(E) from test1 group by A,B
Union all
Select A,null,sum(E) from test1 group by A
Union all
Select A,null,sum(E) from test1 group by A;</code></p>
<h2 id="6_grouping()、grouping_id()、group_id()">6 grouping()、grouping_id()、group_id()</h2><h3 id="6-1_grouping()">6.1 grouping()</h3><p>参数只有一个，而且必须为group by中出现的某一列，表示结果集的一行是否对该列做了grouping。对于对该列做了grouping的行而言，grouping()=0，反之为1；</p>
<h3 id="6-2_grouping_id()">6.2 grouping_id()</h3><p>参数可以是多个，但必须为group by中出现的列。Grouping_id()的返回值其实就是参数中的每列的grouping()值的二进制向量，例如如果grouping(A)=1，grouping(B)=0，则grouping_id(A,B)的返回值就是二进制的10，转成10进制就是2。</p>
<h3 id="6-3_group_id()">6.3 group_id()</h3><p>无参数。见上面的说明3），group by对某些列的集合会进行重复的grouping，而实际上绝大多数情况下对结果集中的这些重复行是不需要的，那就必须有办法剔出这些重复grouping的行。当结果集中有n条重复grouping而形成的行时，每行的group_id()分别是0,1,…,n，这样我们在条件中加入一个group_id()&lt;1就可以剔出这些重复grouping的行了。</p>
<h2 id="7_示例">7 示例</h2><h3 id="7-1_建表与数据">7.1 建表与数据</h3><p>SQL&gt; <code>create table test(department_id number, a varchar2(20), b varchar2(20));</code></p>
<p>Table created</p>
<p>SQL&gt; <code>insert into test values(10, &#39;A&#39;, &#39;B&#39;);</code></p>
<p>1 row inserted</p>
<p>SQL&gt; <code>commit;</code></p>
<p>Commit complete</p>
<h3 id="7-2_查询语句">7.2 查询语句</h3><p><code>select department_id,
       a,
       b,
       grouping(department_id),
       grouping(a),
       grouping(b)
  from test
 group by rollup(department_id, a, b)
order by 4, 5, 6;
select department_id,
       a,
       b,
       grouping(department_id),
       grouping(a),
       grouping(b)
  from test
 group by cube(department_id, a, b)
order by 4, 5, 6;</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/mondrian-ext-Cal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/08/2014/mondrian-ext-Cal/" class="article-date">
  	<time datetime="2014-12-08T07:35:09.000Z" itemprop="datePublished">12月 8 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/08/2014/mondrian-ext-Cal/">mondrian 源码解读（番外篇）-Calc层次结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="接口层">接口层</h3><p>首先我们看Calc的接口。<br>他下面还有11个其他类型的计算器接口，分别是:</p>
<ul>
<li>VoidCalc   接口 <code>void evaluateVoid(Evaluator evaluator)</code></li>
<li>MemberCalc  接口 <code>Member evaluateMember(Evaluator evaluator)</code></li>
<li>LevelCalc   接口  <code>Level evaluateLevel(Evaluator evaluator)</code></li>
<li>DateTimeCalc  接口 <code>Date evaluateDateTime(Evaluator evaluator)</code></li>
<li>DimensionCalc  接口 <code>Dimension evaluateDimension(Evaluator evaluator)</code></li>
<li>HierarchyCalc 接口 <code>Hierarchy evaluateHierarchy(Evaluator evaluator)</code></li>
<li>DoubleCalc 接口 <code>double evaluateDouble(Evaluator evaluator)</code></li>
<li>BooleanCalc 接口 <code>boolean evaluateBoolean(Evaluator evaluator)</code></li>
<li>TupleCalc 接口 <code>Member[] evaluateTuple(Evaluator evaluator)</code></li>
<li>StringCalc 接口 <code>String evaluateString(Evaluator evaluator)</code></li>
<li>IntegerCalc 接口 <code>int evaluateInteger(Evaluator evaluator)</code></li>
</ul>
<hr>
<h3 id="抽象层">抽象层</h3><p>AbstractCal实现了Calc接口。<br>在它下面有10种不同的抽象计算器，分别实现了上述的11中接口类型。<br>注意AbstractVoidCalc并没有继承。</p>
<ul>
<li>GenericCal 抽象类  实现了所有的Calc下层接口，除了Calc的<code>Object evaluate(Evaluator evaluator)</code>接口</li>
<li>AbstractMemberCalc 抽象类 需实现<code>Member evaluateMember(Evaluator evaluator)</code></li>
<li>AbstractLevelCalc 抽象类 需实现<code>Level evaluateLevel(Evaluator evaluator)</code></li>
<li>AbstractDimensionCalc 抽象类 需实现<code>Dimension evaluateDimension(Evaluator evaluator)</code></li>
<li>AbstractHierarchyCalc 抽象类 需实现<code>Hierarchy evaluateHierarchy(Evaluator evaluator)</code></li>
<li>AbstractDoubleCalc 抽象类 需实现<code>double evaluateDouble(Evaluator evaluator)</code></li>
<li>AbstractBooleanCalc 抽象类 需实现<code>boolean evaluateBoolean(Evaluator evaluator)</code></li>
<li>AbstractTupleCalc 抽象类 需实现<code>Member[] evaluateTuple(Evaluator evaluator)</code></li>
<li>AbstractStringCalc 抽象类 需实现<code>String evaluateString(Evaluator evaluator)</code></li>
<li>AbstractIntegerCalc 抽象类 需实现<code>int evaluateInteger(Evaluator evaluator)</code></li>
</ul>
<hr>
<h3 id="通用层">通用层</h3><p>GenericCal实现了这11个接口并继层了AbstractCal，在它下面还有几个实现类</p>
<ul>
<li>AbstractVoidCalc 具体类，不返回任何值，这个类貌似应该继承AbstractCal即可，没必要继承GenericCal。</li>
<li>ConstantCalc 具体类 求值结果与原参数相同。</li>
<li>TupleValueCalc 具体类 在当前元组上下文中求cell值。</li>
<li>ValueCalc 具体类  直接在当前上下文中求Cell值</li>
<li>MemberArrayValueCalc  在多个成员上下文中求Cell值</li>
<li>CacheCalc 具体类 在缓存中获取Cell值</li>
<li>MemberValueCalc 具体类 在当前成员上下文中求Cell值</li>
</ul>
<hr>
<h3 id="集合层">集合层</h3><p>还有一种特殊类型IterCalc接口也继承了Calc。<br>ListCalc接口也继承IterCalc.<br>他们有4个类</p>
<ul>
<li>AbstractIterCalc实现了IterCalc,并继承了AbstractCal。</li>
<li>AbstractListCalc实现了ListCalc,并继承了AbstractCal。</li>
<li>GenericIterCalc实现了ListCalc和IterCalc，并继承了AbstractCal。</li>
<li>IterableCalc继承了AbstractListCalc</li>
</ul>
<hr>
<h3 id="使用">使用</h3><p>那么问题来了，有了这么多求值器，我应该在程序中使用哪种呢？下面将对如何选择各个层做分析。</p>
<ul>
<li>如果是求一般的成员，维度，数值，级别等等。那么，使用抽象层即可。</li>
<li>如果是求集（Set）类型的，那么使用集合层。</li>
<li>如果是求Cell值或者其他操作，那么使用通用层。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/mondrian-ext-function执行机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/13/2014/mondrian-ext-function执行机制/" class="article-date">
  	<time datetime="2014-11-13T10:07:10.000Z" itemprop="datePublished">11月 13 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/13/2014/mondrian-ext-function执行机制/">mondrian 源码解读（番外篇）-MDX函数的执行过程详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MDX函数的执行过程详解">MDX函数的执行过程详解</h2><p>笔者注：由于将来公司可能会有对函数的二次开发需求，所以为公司写了函数的执行过程，以供将来使用。</p>
<h3 id="一，Query对象的创建">一，Query对象的创建</h3><p>在Query对象中，最主要的是resolve()方法，这里涉及到了2个非常重要的功能。</p>
<ul>
<li><p>第一，轴（查询轴和切片轴）上表达式(Exp)的转换。</p>
<p>  主要是将表达式从UnresolvedFunCall转换为ResolvedFunCall。</p>
</li>
<li><p>第二，轴上的计算器(Calc)的创建。</p>
<p>  主要是针对各个轴如何创建计算器。</p>
</li>
</ul>
<p>下面是的resolve()方法解释：</p>
<pre><code> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">()</span> </span>{
    <span class="keyword">final</span> Validator validator = createValidator(); <span class="comment">//1</span>
    resolve(validator); <span class="comment">// resolve self and children ,2</span>
    <span class="comment">// Create a dummy result so we can use its evaluator</span>
    <span class="keyword">final</span> Evaluator evaluator = Util.createEvaluator(<span class="keyword">this</span>); <span class="comment">//3</span>
    ExpCompiler compiler =
            createCompiler(
                    evaluator, validator, Collections.singletonList(resultStyle)); <span class="comment">//4</span>
    compile(compiler);  <span class="comment">//5</span>
}
</code></pre><ol>
<li>第1行创建校验器(Validator)。</li>
<li>第2行根据Validator转换所有的UnresolvedFunCall到ResolvedFunCall。</li>
<li>第3行针对当前Query创建求值器(Evaluator)。</li>
<li>第4行根据求值器，校验器创建表达式编译器(ExpCompiler)。</li>
<li>第5行根据表达式编译器编译所有的轴，并创建轴上的计算器。</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2014/11/13/2014/mondrian-ext-function执行机制/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/mondrian-source-code-7" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/02/2014/mondrian-source-code-7/" class="article-date">
  	<time datetime="2014-11-02T10:07:10.000Z" itemprop="datePublished">11月 2 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/02/2014/mondrian-source-code-7/">mondrian 源码解读（七）-读取member</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面几节中我们了解了cube的创建和query的创建。有了这2样东西后，我们就可以开始执行mdx语句了。在第二小节中，我们了解了mdx的执行顺序。</p>
<ol>
<li>先执行from，即表示从哪个cube中获取结果。</li>
<li>再执行where，with和axis，即获取member阶段。</li>
<li>有了所有依赖的成员后，最后执行Cell的值。</li>
</ol>
<p>cube的创建已经在前一节中讲过了，接着是member获取阶段，由于这一阶段分为3部分，内容比较多。所以下面我们先将member是如何读取的，后几节再介绍它的执行过程。</p>
<h2 id="MemberSource">MemberSource</h2><p>所有对成员的读取操作都是通过MemberSource来完成的。<br>MemberSource基本功能就是是读取层次的成员操作。<br>我们看下它的基本接口：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberSource</span> </span>{

    <span class="function">RolapHierarchy <span class="title">getHierarchy</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">boolean</span> <span class="title">setCache</span><span class="params">(MemberCache cache)</span></span>;

    <span class="function">List&lt;RolapMember&gt; <span class="title">getMembers</span><span class="params">()</span></span>;

    <span class="function">List&lt;RolapMember&gt; <span class="title">getRootMembers</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">getMemberChildren</span><span class="params">(
        RolapMember parentMember,
        List&lt;RolapMember&gt; children)</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">getMemberChildren</span><span class="params">(
        List&lt;RolapMember&gt; parentMembers,
        List&lt;RolapMember&gt; children)</span></span>;

    <span class="function"><span class="keyword">int</span> <span class="title">getMemberCount</span><span class="params">()</span></span>;

    <span class="function">RolapMember <span class="title">lookupMember</span><span class="params">(
        List&lt;Id.Segment&gt; uniqueNameParts,
        <span class="keyword">boolean</span> failIfNotFound)</span></span>;
}    
</code></pre><p>从上面我们可以看到，有3个最基本的接口，分别是获取层次，即当前的MemberSource属于哪个层次，设置缓存对象（为了从缓存中读取member），和获得当前层次的成员。这就是MemberSource的核心功能。</p>
<h2 id="MemberReader">MemberReader</h2><p>我们先看MemberReader的层次图。<br><img src="/img/2014/QQ图片20141102182120.jpg" alt=""><br>从上图中我们看到，MemberReader是继承的MemberSource，所以MemberReader具有MemberSource所有的功能。那么它有哪些功能呢？<br>我们看看它的接口:</p>
<pre><code><span class="class"><span class="keyword">interface</span> <span class="title">MemberReader</span> <span class="keyword">extends</span> <span class="title">MemberSource</span> </span>{

    <span class="function">RolapMember <span class="title">getLeadMember</span><span class="params">(RolapMember member, <span class="keyword">int</span> n)</span></span>;


    <span class="function">List&lt;RolapMember&gt; <span class="title">getMembersInLevel</span><span class="params">(
        RolapLevel level)</span></span>;


    <span class="function"><span class="keyword">void</span> <span class="title">getMemberRange</span><span class="params">(
        RolapLevel level,
        RolapMember startMember,
        RolapMember endMember,
        List&lt;RolapMember&gt; list)</span></span>;

    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(
        RolapMember m1,
        RolapMember m2,
        <span class="keyword">boolean</span> siblingsAreEqual)</span></span>;

    Map&lt;? extends Member, Access&gt; getMemberChildren(
        RolapMember member,
        List&lt;RolapMember&gt; children,
        MemberChildrenConstraint constraint);

    Map&lt;? extends Member, Access&gt; getMemberChildren(
        List&lt;RolapMember&gt; parentMembers,
        List&lt;RolapMember&gt; children,
        MemberChildrenConstraint constraint);

    <span class="function">List&lt;RolapMember&gt; <span class="title">getMembersInLevel</span><span class="params">(
        RolapLevel level,
        TupleConstraint constraint)</span></span>;

    <span class="function"><span class="keyword">int</span> <span class="title">getLevelMemberCount</span><span class="params">(RolapLevel level)</span></span>;

    <span class="function">MemberBuilder <span class="title">getMemberBuilder</span><span class="params">()</span></span>;

    <span class="function">RolapMember <span class="title">getDefaultMember</span><span class="params">()</span></span>;

    <span class="function">RolapMember <span class="title">getMemberParent</span><span class="params">(RolapMember member)</span></span>;

    <span class="function">RolapMember <span class="title">substitute</span><span class="params">(RolapMember member)</span></span>;

    <span class="function">RolapMember <span class="title">desubstitute</span><span class="params">(RolapMember member)</span></span>;

    <span class="function">RolapMember <span class="title">getMemberByKey</span><span class="params">(
        RolapLevel level,
        List&lt;Comparable&gt; keyValues)</span></span>;
}
</code></pre><p>从上面大家发现没，MemberReader更细化功能，它可以获取到Level上的成员，也可以获取成员的父成员或者成员的子成员，并且在获取成员的时候可以添加约束条件。有了这些功能，我们就可以任意的获取成员了，所以MemberReader是成员获取的主接口。</p>
<h2 id="具体实现">具体实现</h2><h3 id="SmartMemberReader">SmartMemberReader</h3><p>SmartMemberReader实现了MemberReader接口，它实现了维度成员及其子成员的缓存，如果有一个成员位于缓存中，则还会有一个其子成员的列表。它同时缓存了level下的成员们。该类主要的成员有：</p>
<ul>
<li>source：MemberReader，用于实际从数据库中读取维度成员值。</li>
<li>mapMemberToChildren：map，实现成员及其子成员的映射， key为RolapMember，value为List<rolapmember>。</rolapmember></li>
<li>mapKeyToMember： map ，实现所有成员的缓存，其中的key为MmberKey</li>
<li>mapLevelToMembers: map，实现级别及其所有成员的映射， key为RolapLevel，value为List<rolapmember>。</rolapmember></li>
</ul>
<h3 id="SqlMemberSource">SqlMemberSource</h3><p>SqlMemberSource是最终更数据库打交道的类，它会针对要查询对Level生成一个sql，该sql最终通过数据库执行，将查询结果返回后拼装成member。需要注意的一点是，如果该member有parentmember，必须要生成其对应的parentmember。生成过程即先递归的在level中查找其上一级level的member是否缓存，如果没有缓存，则将其加入查询列表中，直到上一级为空或缓存了member。找到所有要查询的level后，最后一次性生成sql向数据库查询数据。</p>
<p>SmartMemberReader的source其实为mondrian.rolap.SqlMemberSource类，该类中反过来又存储了SmartMemberReader对象，作为其cache成员属性。成员读取过程：</p>
<ol>
<li>smartMemberReader.getMemberChildren(parentMembers,children,constrain);</li>
<li>最终通过source.getMemberChildren()…，其中反过来会把找到的children赋予mapKeyToMember。</li>
<li>最终除了将结果返回在children输出参数中，同时也对mapMemberToChildren赋值了。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/mondrian-source-code-6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/26/2014/mondrian-source-code-6/" class="article-date">
  	<time datetime="2014-10-26T10:07:05.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/2014/mondrian-source-code-6/">mondrian 源码解读（六）-创建CUBE</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在第4节中，构建query的时候，有一个非常重要的东西被我忽略了，那就是构建cube <code>Util.lookupCube(statement.getSchemaReader(), cube, true)</code>，下面我们来谈谈cube是如何构建的。</p>
<h2 id="Cube是什么？">Cube是什么？</h2><p>在第2节中，我们已经谈论了cube，即维度和度量的组合。</p>
<h2 id="RolapCube">RolapCube</h2><p>在理解了Cube后，我们就可以理解RolapCube了。根据字面意思，我们也可以理解为关系型联机分析处理cube。我们看看它里面主要是实体对象：</p>
<pre><code><span class="comment">//不解释</span>
<span class="keyword">protected</span> Dimension[] dimensions;

<span class="comment">//</span>
<span class="keyword">private</span> <span class="keyword">final</span> RolapHierarchy measuresHierarchy;

<span class="comment">/**
 * List of calculated members.
 * 定义在schema中的计算成员，注意公式是如何转换的呢？
 */</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Formula&gt; calculatedMemberList = <span class="keyword">new</span> ArrayList&lt;Formula&gt;();

<span class="keyword">private</span> RolapStar star; <span class="comment">//关联的星型模型</span>

<span class="comment">//在Evaluator中用于计算当前成员是否为空，如果当前度量成员中有count聚合，即为当前成员，如果没有找到，创建一个虚拟的count聚合为测量的成员。</span>
RolapBaseCubeMeasure factCountMeasure;
</code></pre><p>calculatedMemberList这里谈一下。如何将schema中定义的计算成员转换成已近解析好的Formula？<br>这里其实很简单，通过构造一个特定的mdx：<br><code>with member [Measures].[aa] as &#39;expression1&#39; ,
[Measures].[bb] as &#39;expression2&#39;select from cube</code><br>然后使用parser解析器解析mdx后返回一个query，query里面的计算成员即为此计算成员。</p>
<h2 id="RolapStar是什么？">RolapStar是什么？</h2><p>我们可以将它理解为一个关联了物理表之间的关系的对象。通过它来生成特定的sql，查询需要的数据。<br>具体实体对象大家可以打开看看，这里不做详细的解释了。</p>
<pre><code><span class="keyword">private</span> DataSource dataSource;
<span class="keyword">private</span> <span class="keyword">final</span> Table factTable;
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Column&gt; columnList = <span class="keyword">new</span> ArrayList&lt;Column&gt;();

Table对象..星型模型
<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> RolapStar star;
    <span class="keyword">private</span> <span class="keyword">final</span> MondrianDef.Relation relation;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Column&gt; columnList;
    <span class="keyword">private</span> <span class="keyword">final</span> Table <span class="keyword">parent</span>;
    <span class="keyword">private</span> <span class="keyword">List</span>&lt;Table&gt; children;
    <span class="keyword">private</span> <span class="keyword">final</span> Condition joinCondition;
    <span class="keyword">private</span> <span class="keyword">final</span> String alias;
}
</code></pre><h2 id="源码修改">源码修改</h2><p>cube的创建是根据schema中定义的属性配置来创建cube，这部分没有细看，如何创建其实我们并不关系，理解cube的数据结构就行了。</p>
<p>我们在修改mondrian源码时，将cube创建这块全部去掉了，取而代之的使用了自己的cube创建方式。由于我们底层的存储结构不依赖与xml，而是我们自己定义好的实体间的关系，所以我们将我们的实体转换成了cube。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2014/mondrian-source-code-5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/26/2014/mondrian-source-code-5/" class="article-date">
  	<time datetime="2014-10-26T08:06:12.000Z" itemprop="datePublished">10月 26 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/2014/mondrian-source-code-5/">mondrian 源码解读（五）-访问者模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上一节中，我们看到在resolve()方法中使用了大量的访问者模式，所以下面我们总结下：</p>
<h2 id="什么是访问者模式">什么是访问者模式</h2><p>我发现还是GOF书中定义的最好，就拿过来了。</p>
<h3 id="意图">意图</h3><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提<br>下定义作用于这些元素的新操作。</p>
<h3 id="结构图">结构图</h3><p><img src="/img/2014/QQ图片20141026172247.jpg" alt=""><br>
      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mondrian/">mondrian</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2014/10/26/2014/mondrian-source-code-5/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 sqtds
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>